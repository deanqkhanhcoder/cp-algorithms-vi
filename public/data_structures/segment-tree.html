
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Bản dịch tiếng Việt của dự án cp-algorithms">
      
      
      
        <link rel="canonical" href="https://deanqkhanhcoder.github.io/cp-algorithms-vi/data_structures/segment-tree.html">
      
      
        <link rel="prev" href="sqrt-decomposition.html">
      
      
        <link rel="next" href="treap.html">
      
      
        
      
      
      <link rel="icon" href="../favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>Segment Tree - Algorithms for Competitive Programming</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Be+Vietnam+Pro:300,300i,400,400i,700,700i%7CJetBrains+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Be Vietnam Pro";--md-code-font:"JetBrains Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../stylesheets/extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  <script src="../assets/javascripts/toggle-sidebar.js"></script></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#segment-tree" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <script>
    function scrollToTop() {
      document.body.scrollTop = 0;
      document.documentElement.scrollTop = 0;
    }
  </script>
  <nav class="md-header__inner md-grid" aria-label="header.title">
    <a href=".." title="Algorithms for Competitive Programming"
      class="md-header__button md-logo" aria-label="Algorithms for Competitive Programming" data-md-component="logo">
      
  <img src="../favicon.ico" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            <a href=".." title="Algorithms for Competitive Programming"
              aria-label="Algorithms for Competitive Programming" data-md-component="logo">
              Algorithms for Competitive Programming
            </a>
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            <a href="#" onclick="scrollToTop()">
              
              Segment Tree
              
            </a>
          </span>
        </div>
      </div>
    </div>

    
    <label class="md-header__button md-icon" for="__search">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
    </label>
    <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    

    <div class="md-header__option">
      <a href="https://www.instagram.com/deanqkhanh" title="Instagram" class="md-header__button md-icon"
        aria-label="Instagram">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M224.3 141a115 115 0 1 0-.6 230 115 115 0 1 0 .6-230m-.6 40.4a74.6 74.6 0 1 1 .6 149.2 74.6 74.6 0 1 1-.6-149.2m93.4-45.1a26.8 26.8 0 1 1 53.6 0 26.8 26.8 0 1 1-53.6 0m129.7 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8M399 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1"/></svg>
      </a>
    </div>

    <div class="md-header__option">
      <a href="https://github.com/deanqkhanhcoder/donate" title="GitHub Sponsors" class="md-header__button md-icon"
        aria-label="GitHub Sponsors">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M96 224a192 192 0 1 1 384 0 192 192 0 1 1-384 0m176-92v4c-28.8.3-52 23.7-52 52.5 0 25.7 18.5 47.6 43.9 51.8l41.7 7c6 1 10.4 6.2 10.4 12.3 0 6.9-5.6 12.5-12.5 12.5L248 272c-11 0-20 9-20 20s9 20 20 20h24v4c0 11 9 20 20 20s20-9 20-20v-4.7c25-4.1 44-25.7 44-51.8 0-25.7-18.5-47.6-43.9-51.8l-41.7-7c-6-1-10.4-6.2-10.4-12.3 0-6.9 5.6-12.5 12.5-12.5H320c11 0 20-9 20-20s-9-20-20-20h-8v-4c0-11-9-20-20-20s-20 9-20 20zM48 344v104c0 8.8 7.2 16 16 16h448c8.8 0 16-7.2 16-16V344c0-13.3 10.7-24 24-24s24 10.7 24 24v104c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V344c0-13.3 10.7-24 24-24s24 10.7 24 24"/></svg>
      </a>
    </div>

    
    <form class="md-header__option" data-md-component="palette">
      
      
      
      <input class="md-option" data-md-color-media="" data-md-color-scheme="slate"
        data-md-color-primary="indigo" data-md-color-accent="indigo" 
        aria-label="Switch to light mode"  type="radio" name="__palette"
        id="__palette_1">
      
      <label class="md-header__button md-icon" title="Switch to light mode"
        for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
      
      
      
      
      <input class="md-option" data-md-color-media="" data-md-color-scheme="default"
        data-md-color-primary="indigo" data-md-color-accent="indigo" 
        aria-label="Switch to dark mode"  type="radio" name="__palette"
        id="__palette_2">
      
      <label class="md-header__button md-icon" title="Switch to dark mode"
        for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
      
      
    </form>
    

    
    <div class="md-header__source">
      <a href="https://github.com/deanqkhanhcoder/cp-algorithms-vi" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    deanqkhanhcoder/cp-algorithms-vi
  </div>
</a>
    </div>
    

  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



  

<nav class="md-nav md-nav--primary md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Algorithms for Competitive Programming" class="md-nav__button md-logo" aria-label="Algorithms for Competitive Programming" data-md-component="logo">
      
  <img src="../favicon.ico" alt="logo">

    </a>
    Algorithms for Competitive Programming
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/deanqkhanhcoder/cp-algorithms-vi" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    deanqkhanhcoder/cp-algorithms-vi
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" >
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Trang chủ
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Trang chủ
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../index.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Trang chủ
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../navigation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Điều hướng
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tags.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Danh mục thẻ
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../contrib.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Cách đóng góp
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../code-of-conduct.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Quy tắc ứng xử
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../preview.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Xem trước
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Đại số
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Đại số
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" >
        
          
          <label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Cơ bản
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Cơ bản
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/binary-exp.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Lũy thừa nhị phân
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/euclid-algorithm.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Thuật toán Euclid tìm ước chung lớn nhất
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/extended-euclid-algorithm.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Thuật toán Euclid mở rộng
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/linear-diophantine-equation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Phương trình Diophantine tuyến tính
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/fibonacci-numbers.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Số Fibonacci
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Số nguyên tố
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Số nguyên tố
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/sieve-of-eratosthenes.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Sàng Eratosthenes
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/prime-sieve-linear.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Sàng tuyến tính
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/primality-tests.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Kiểm tra số nguyên tố
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/factorization.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Phân tích thừa số nguyên tố
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Hàm lý thuyết số
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Hàm lý thuyết số
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/phi-function.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hàm phi Euler
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/divisors.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Số lượng ước / Tổng các ước
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_4" >
        
          
          <label class="md-nav__link" for="__nav_2_4" id="__nav_2_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Số học module
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Số học module
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/module-inverse.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Nghịch đảo module
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/linear-congruence-equation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Phương trình đồng dư tuyến tính
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/chinese-remainder-theorem.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Định lý thặng dư Trung Hoa
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/garners-algorithm.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Thuật toán Garner
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/factorial-modulo.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Giai thừa modulo p
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/discrete-log.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Logarit rời rạc
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/primitive-root.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Căn nguyên thủy
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/discrete-root.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Căn rời rạc
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/montgomery-multiplication.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Nhân Montgomery
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_5" >
        
          
          <label class="md-nav__link" for="__nav_2_5" id="__nav_2_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Hệ đếm
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_5">
            <span class="md-nav__icon md-icon"></span>
            
  
    Hệ đếm
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/balanced-ternary.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hệ tam phân cân bằng
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/gray-code.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Mã Gray
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_6" >
        
          
          <label class="md-nav__link" for="__nav_2_6" id="__nav_2_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Khác
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_6">
            <span class="md-nav__icon md-icon"></span>
            
  
    Khác
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/bit-manipulation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Thao tác bit
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/all-submasks.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Liệt kê submask của một bitmask
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/big-integer.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Số học độ chính xác tùy ý
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/fft.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Biến đổi Fourier nhanh (FFT)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/polynomial.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Các phép toán trên đa thức và chuỗi
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/continued-fractions.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Liên phân số
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/factoring-exp.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Phân tích lũy thừa (Factoring Exponentiation)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Cấu trúc dữ liệu
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Cấu trúc dữ liệu
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Cơ bản
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Cơ bản
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="stack-queue-modification.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Minimum Stack / Minimum Queue
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="sparse-table.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Sparse Table
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" checked>
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Cây
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Cây
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="disjoint-set-union.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Disjoint Set Union (DSU)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="fenwick.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Fenwick Tree
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="sqrt-decomposition.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Sqrt Decomposition
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    Segment Tree
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="segment-tree.html" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Segment Tree
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#simplest-form-of-a-segment-tree" class="md-nav__link">
    <span class="md-ellipsis">
      
        Dạng đơn giản nhất của Segment Tree (Simplest form of a Segment Tree)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Dạng đơn giản nhất của Segment Tree (Simplest form of a Segment Tree)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#structure-of-the-segment-tree" class="md-nav__link">
    <span class="md-ellipsis">
      
        Cấu trúc của Segment Tree (Structure of the Segment Tree)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#construction" class="md-nav__link">
    <span class="md-ellipsis">
      
        Xây dựng (Construction)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sum-queries" class="md-nav__link">
    <span class="md-ellipsis">
      
        Truy vấn tổng (Sum queries)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update-queries" class="md-nav__link">
    <span class="md-ellipsis">
      
        Truy vấn cập nhật (Update queries)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#implementation" class="md-nav__link">
    <span class="md-ellipsis">
      
        Cài đặt (Implementation)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#memory-efficient-implementation" class="md-nav__link">
    <span class="md-ellipsis">
      
        Cài đặt hiệu quả bộ nhớ (Memory efficient implementation)
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#advanced-versions-of-segment-trees" class="md-nav__link">
    <span class="md-ellipsis">
      
        Các phiên bản nâng cao của Segment Trees (Advanced versions of Segment Trees)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Các phiên bản nâng cao của Segment Trees (Advanced versions of Segment Trees)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#more-complex-queries" class="md-nav__link">
    <span class="md-ellipsis">
      
        Các truy vấn phức tạp hơn (More complex queries)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Các truy vấn phức tạp hơn (More complex queries)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#finding-the-maximum" class="md-nav__link">
    <span class="md-ellipsis">
      
        Tìm giá trị lớn nhất (Finding the maximum)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#finding-the-maximum-and-the-number-of-times-it-appears" class="md-nav__link">
    <span class="md-ellipsis">
      
        Tìm giá trị lớn nhất và số lần xuất hiện của nó (Finding the maximum and the number of times it appears)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compute-the-greatest-common-divisor-least-common-multiple" class="md-nav__link">
    <span class="md-ellipsis">
      
        Tính ước chung lớn nhất / bội chung nhỏ nhất (Compute the greatest common divisor / least common multiple)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#counting-zero-search-kth" class="md-nav__link">
    <span class="md-ellipsis">
      
        Counting the number of zeros, searching for the k-th zero
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#searching-for-an-array-prefix-with-a-given-amount" class="md-nav__link">
    <span class="md-ellipsis">
      
        Tìm kiếm tiền tố mảng với một lượng nhất định (Searching for an array prefix with a given amount)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#searching-for-the-first-element-greater-than-a-given-amount" class="md-nav__link">
    <span class="md-ellipsis">
      
        Tìm kiếm phần tử đầu tiên lớn hơn một lượng nhất định (Searching for the first element greater than a given amount)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#finding-subsegments-with-the-maximal-sum" class="md-nav__link">
    <span class="md-ellipsis">
      
        Tìm các đoạn con có tổng lớn nhất (Finding subsegments with the maximal sum)
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#luu-tru-toan-bo-mang-con-trong-moi-nut-saving-the-entire-subarrays-in-each-vertex" class="md-nav__link">
    <span class="md-ellipsis">
      
        Lưu trữ toàn bộ mảng con trong mỗi nút (Saving the entire subarrays in each vertex)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lưu trữ toàn bộ mảng con trong mỗi nút (Saving the entire subarrays in each vertex)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tim-so-nho-nhat-lon-hon-hoac-bang-mot-so-a-chi-inh-khong-co-truy-van-sua-oi" class="md-nav__link">
    <span class="md-ellipsis">
      
        Tìm số nhỏ nhất lớn hơn hoặc bằng một số đã chỉ định. Không có truy vấn sửa đổi.
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tim-so-nho-nhat-lon-hon-hoac-bang-mot-so-a-chi-inh-voi-cac-truy-van-sua-oi" class="md-nav__link">
    <span class="md-ellipsis">
      
        Tìm số nhỏ nhất lớn hơn hoặc bằng một số đã chỉ định. Với các truy vấn sửa đổi.
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tim-so-nho-nhat-lon-hon-hoac-bang-mot-so-a-chi-inh-tang-toc-voi-fractional-cascading" class="md-nav__link">
    <span class="md-ellipsis">
      
        Tìm số nhỏ nhất lớn hơn hoặc bằng một số đã chỉ định. Tăng tốc với "fractional cascading".
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#other-possible-variations" class="md-nav__link">
    <span class="md-ellipsis">
      
        Các biến thể có thể khác (Other possible variations)
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#range-updates-lazy-propagation" class="md-nav__link">
    <span class="md-ellipsis">
      
        Cập nhật đoạn (Lazy Propagation)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Cập nhật đoạn (Lazy Propagation)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#addition-on-segments" class="md-nav__link">
    <span class="md-ellipsis">
      
        Cộng trên các đoạn (Addition on segments)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assignment-on-segments" class="md-nav__link">
    <span class="md-ellipsis">
      
        Gán trên các đoạn (Assignment on segments)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adding-on-segments-querying-for-maximum" class="md-nav__link">
    <span class="md-ellipsis">
      
        Cộng trên các đoạn, truy vấn giá trị lớn nhất (Adding on segments, querying for maximum)
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#khai-quat-hoa-sang-cac-chieu-cao-hon-generalization-to-higher-dimensions" class="md-nav__link">
    <span class="md-ellipsis">
      
        Khái quát hóa sang các chiều cao hơn (Generalization to higher dimensions)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Khái quát hóa sang các chiều cao hơn (Generalization to higher dimensions)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#simple-2d-segment-tree" class="md-nav__link">
    <span class="md-ellipsis">
      
        Segment Tree 2D đơn giản (Simple 2D Segment Tree)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compression-of-2d-segment-tree" class="md-nav__link">
    <span class="md-ellipsis">
      
        Nén Segment Tree 2D (Compression of 2D Segment Tree)
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#preserving-the-history-of-its-values-persistent-segment-tree" class="md-nav__link">
    <span class="md-ellipsis">
      
        Bảo tồn lịch sử các giá trị của nó (Persistent Segment Tree)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Bảo tồn lịch sử các giá trị của nó (Persistent Segment Tree)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#finding-the-k-th-smallest-number-in-a-range" class="md-nav__link">
    <span class="md-ellipsis">
      
        Finding the k-th smallest number in a range
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dynamic-segment-tree" class="md-nav__link">
    <span class="md-ellipsis">
      
        Segment tree động (Dynamic segment tree)
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#practice-problems" class="md-nav__link">
    <span class="md-ellipsis">
      
        Bài tập (Practice Problems)
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="treap.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Treap
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="sqrt-tree.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Sqrt Tree
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="randomized-heap.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Randomized Heap
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Nâng cao
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Nâng cao
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="deleting-in-log-n.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Xóa khỏi cấu trúc dữ liệu trong O(T(n) log n)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Quy hoạch động
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Quy hoạch động
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/intro-to-dp.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Giới thiệu về Quy hoạch động
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/knapsack.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bài toán cái túi
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/longest-increasing-subsequence.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dãy con tăng dài nhất
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_4" >
        
          
          <label class="md-nav__link" for="__nav_4_4" id="__nav_4_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Tối ưu hóa DP
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Tối ưu hóa DP
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/divide-and-conquer-dp.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Quy hoạch động chia để trị
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/knuth-optimization.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tối ưu hóa Knuth
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_5" >
        
          
          <label class="md-nav__link" for="__nav_4_5" id="__nav_4_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Bài tập
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_5">
            <span class="md-nav__icon md-icon"></span>
            
  
    Bài tập
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/profile-dynamics.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Quy hoạch động trên profile gãy. Bài toán "Parquet"
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/zero-matrix.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm ma trận con toàn số 0 lớn nhất
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Xử lý chuỗi
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            
  
    Xử lý chuỗi
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_1" >
        
          
          <label class="md-nav__link" for="__nav_5_1" id="__nav_5_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Cơ bản
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Cơ bản
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/string-hashing.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Băm chuỗi (String Hashing)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/rabin-karp.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Thuật toán Rabin-Karp cho so khớp chuỗi
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/prefix-function.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hàm tiền tố - Knuth-Morris-Pratt
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/z-function.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hàm Z (Z-function)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/suffix-array.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Suffix Array
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/aho-corasick.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Thuật toán Aho-Corasick
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2" >
        
          
          <label class="md-nav__link" for="__nav_5_2" id="__nav_5_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Nâng cao
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Nâng cao
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/suffix-tree-ukkonen.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Suffix Tree
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/suffix-automaton.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Suffix Automaton
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/lyndon-factorization.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Phân rã Lyndon
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_3" >
        
          
          <label class="md-nav__link" for="__nav_5_3" id="__nav_5_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Bài tập
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Bài tập
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/expression-parsing.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Phân tích biểu thức
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/manacher.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Thuật toán Manacher - Tìm tất cả các palindrome con trong O(N)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/main-lorentz.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm lặp lại
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Đại số tuyến tính
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            
  
    Đại số tuyến tính
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_1" >
        
          
          <label class="md-nav__link" for="__nav_6_1" id="__nav_6_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Ma trận
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_6_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Ma trận
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../linear_algebra/linear-system-gauss.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Gauss & Hệ phương trình tuyến tính
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../linear_algebra/determinant-gauss.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Gauss & Định thức
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../linear_algebra/determinant-kraut.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Kraut & Định thức
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../linear_algebra/rank-matrix.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hạng của ma trận
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Tổ hợp
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            
  
    Tổ hợp
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_1" >
        
          
          <label class="md-nav__link" for="__nav_7_1" id="__nav_7_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Cơ bản
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_7_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Cơ bản
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/factorial-divisors.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm số mũ của ước giai thừa
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/binomial-coefficients.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hệ số nhị thức
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/catalan-numbers.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Số Catalan
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_2" >
        
          
          <label class="md-nav__link" for="__nav_7_2" id="__nav_7_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Kỹ thuật
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_7_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Kỹ thuật
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/inclusion-exclusion.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Nguyên lý bao hàm - loại trừ
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/burnside.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bổ đề Burnside / Định lý liệt kê Pólya
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/stars-and-bars.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bài toán chia kẹo (Stars and bars)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/generating-combinations.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Sinh tất cả tổ hợp chập K
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_3" >
        
          
          <label class="md-nav__link" for="__nav_7_3" id="__nav_7_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Bài tập
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_7_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Bài tập
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/bishops-on-chessboard.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Xếp quân Tượng trên bàn cờ
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/bracket-sequences.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dãy ngoặc đúng
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/counting-labeled-graphs.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Đếm đồ thị có nhãn
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Phương pháp số
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            
  
    Phương pháp số
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_1" >
        
          
          <label class="md-nav__link" for="__nav_8_1" id="__nav_8_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Tìm kiếm
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Tìm kiếm
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/binary-search.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm kiếm nhị phân
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/ternary-search.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm kiếm tam phân
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/roots-newton.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Phương pháp Newton tìm nghiệm
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/simulated-annealing.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Mô phỏng luyện kim (Simulated Annealing)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_2" >
        
          
          <label class="md-nav__link" for="__nav_8_2" id="__nav_8_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Tích phân
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Tích phân
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/simpson-integration.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tích phân theo công thức Simpson
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Hình học
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            
  
    Hình học
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_1" >
        
          
          <label class="md-nav__link" for="__nav_9_1" id="__nav_9_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Phép toán cơ bản
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Phép toán cơ bản
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/basic-geometry.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hình học cơ bản
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/segment-to-line.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm phương trình đường thẳng đi qua đoạn thẳng
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/lines-intersection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Giao điểm của đường thẳng
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/check-segments-intersection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Kiểm tra hai đoạn thẳng cắt nhau
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/segments-intersection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Giao của các đoạn thẳng
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/circle-line-intersection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Giao của đường tròn và đường thẳng
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/circle-circle-intersection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Giao của hai đường tròn
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/tangents-to-two-circles.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tiếp tuyến chung của hai đường tròn
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/length-of-segments-union.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Độ dài hợp của các đoạn thẳng
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_2" >
        
          
          <label class="md-nav__link" for="__nav_9_2" id="__nav_9_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Đa giác
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Đa giác
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/oriented-triangle-area.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Diện tích có hướng của tam giác
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/area-of-simple-polygon.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Diện tích đa giác đơn
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/point-in-convex-polygon.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Kiểm tra điểm thuộc đa giác lồi trong O(log N)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/minkowski.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tổng Minkowski của các đa giác lồi
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/picks-theorem.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Định lý Pick - diện tích đa giác nguyên
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/lattice-points.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Điểm nguyên của đa giác không nguyên
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_3" >
        
          
          <label class="md-nav__link" for="__nav_9_3" id="__nav_9_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Bao lồi
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Bao lồi
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/convex-hull.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Xây dựng bao lồi
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/convex-hull-trick.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Convex hull trick và Li Chao tree
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_4" >
        
          
          <label class="md-nav__link" for="__nav_9_4" id="__nav_9_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Sweep-line
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Sweep-line
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/intersecting-segments.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm cặp đoạn thẳng cắt nhau
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_5" >
        
          
          <label class="md-nav__link" for="__nav_9_5" id="__nav_9_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Đồ thị phẳng
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_5">
            <span class="md-nav__icon md-icon"></span>
            
  
    Đồ thị phẳng
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/planar.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm các mặt của đồ thị phẳng
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/point-location.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Xác định vị trí điểm trong O(log N)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_6" >
        
          
          <label class="md-nav__link" for="__nav_9_6" id="__nav_9_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Khác
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_6">
            <span class="md-nav__icon md-icon"></span>
            
  
    Khác
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/nearest-points.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm cặp điểm gần nhất
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/delaunay.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tam giác hóa Delaunay và biểu đồ Voronoi
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/vertical-decomposition.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Phân rã dọc (Vertical decomposition)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/halfplane-intersection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Giao nửa mặt phẳng - Thuật toán S&I trong O(N log N)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/manhattan-distance.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Khoảng cách Manhattan
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/enclosing-circle.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Đường tròn bao nhỏ nhất
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          <label class="md-nav__link" for="__nav_10" id="__nav_10_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Đồ thị
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            
  
    Đồ thị
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_1" >
        
          
          <label class="md-nav__link" for="__nav_10_1" id="__nav_10_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Duyệt đồ thị
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Duyệt đồ thị
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/breadth-first-search.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Breadth First Search (BFS)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/depth-first-search.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Depth First Search (DFS)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_2" >
        
          
          <label class="md-nav__link" for="__nav_10_2" id="__nav_10_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Thành phần liên thông, cầu, khớp
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Thành phần liên thông, cầu, khớp
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/search-for-connected-components.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm thành phần liên thông
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/bridge-searching.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm cầu trong O(N+M)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/bridge-searching-online.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm cầu Online
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/cutpoints.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm khớp trong O(N+M)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/strongly-connected-components.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Thành phần liên thông mạnh và đồ thị nén
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/strong-orientation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Định hướng mạnh
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_3" >
        
          
          <label class="md-nav__link" for="__nav_10_3" id="__nav_10_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Đường đi ngắn nhất từ một nguồn
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Đường đi ngắn nhất từ một nguồn
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/dijkstra.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dijkstra - tìm đường đi ngắn nhất từ một đỉnh
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/dijkstra-sparse.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dijkstra trên đồ thị thưa
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/bellman-ford.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bellman-Ford - tìm đường đi ngắn nhất với trọng số âm
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/01-bfs.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    0-1 BFS
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/desopo-pape.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Thuật toán D´Esopo-Pape
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_4" >
        
          
          <label class="md-nav__link" for="__nav_10_4" id="__nav_10_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Đường đi ngắn nhất giữa mọi cặp đỉnh
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Đường đi ngắn nhất giữa mọi cặp đỉnh
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/all-pair-shortest-path-floyd-warshall.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Floyd-Warshall - tìm mọi đường đi ngắn nhất
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/fixed-length-paths.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Số đường đi độ dài cố định / Đường đi ngắn nhất độ dài cố định
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_5" >
        
          
          <label class="md-nav__link" for="__nav_10_5" id="__nav_10_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Cây khung
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_5">
            <span class="md-nav__icon md-icon"></span>
            
  
    Cây khung
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/mst-prim.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Cây khung nhỏ nhất - Thuật toán Prim
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/mst-kruskal.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Cây khung nhỏ nhất - Thuật toán Kruskal
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/mst-kruskal-with-dsu.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Cây khung nhỏ nhất - Kruskal và DSU
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/second-best-mst.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Cây khung nhỏ nhất thứ hai - Dùng Kruskal và LCA
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/kirchhoff-theorem.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Định lý Kirchhoff
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/pruefer-code.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Mã Prüfer
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_6" >
        
          
          <label class="md-nav__link" for="__nav_10_6" id="__nav_10_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Chu trình
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_6">
            <span class="md-nav__icon md-icon"></span>
            
  
    Chu trình
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/finding-cycle.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Kiểm tra tính không chu trình và tìm chu trình trong O(M)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/finding-negative-cycle-in-graph.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm chu trình âm trong đồ thị
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/euler-path.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Đường đi Euler
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_7" >
        
          
          <label class="md-nav__link" for="__nav_10_7" id="__nav_10_7_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Lowest Common Ancestor
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_7">
            <span class="md-nav__icon md-icon"></span>
            
  
    Lowest Common Ancestor
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/lca.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Lowest Common Ancestor (LCA)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/lca-binary-lifting.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    LCA - Binary Lifting
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/lca-farachcoltonbender.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    LCA - Thuật toán Farach-Colton và Bender
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/rmq-linear.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Giải RMQ bằng LCA
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/lca-tarjan.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    LCA - Thuật toán Tarjan (Offline)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_8" >
        
          
          <label class="md-nav__link" for="__nav_10_8" id="__nav_10_8_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Luồng và các bài toán liên quan
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_8">
            <span class="md-nav__icon md-icon"></span>
            
  
    Luồng và các bài toán liên quan
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/edmonds-karp.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Luồng cực đại - Ford-Fulkerson và Edmonds-Karp
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/push-relabel.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Luồng cực đại - Thuật toán Push-relabel
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/push-relabel-faster.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Luồng cực đại - Thuật toán Push-relabel cải tiến
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/dinic.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Luồng cực đại - Thuật toán Dinic
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/mpm.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Luồng cực đại - Thuật toán MPM
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/flow-with-demands.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Luồng có yêu cầu (Flows with demands)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/min-cost-flow.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Luồng chi phí nhỏ nhất
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/assignment-problem-min-flow.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bài toán phân công
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_9" >
        
          
          <label class="md-nav__link" for="__nav_10_9" id="__nav_10_9_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Cặp ghép và các bài toán liên quan
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_9">
            <span class="md-nav__icon md-icon"></span>
            
  
    Cặp ghép và các bài toán liên quan
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/bipartite-check.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Kiểm tra đồ thị hai phía
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/kuhn-maximum-bipartite-matching.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Thuật toán Kuhn - Cặp ghép cực đại trên đồ thị hai phía
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/hungarian-algorithm.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Thuật toán Hungary
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_10" >
        
          
          <label class="md-nav__link" for="__nav_10_10" id="__nav_10_10_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Khác
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_10">
            <span class="md-nav__icon md-icon"></span>
            
  
    Khác
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/topological-sort.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Sắp xếp topo
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/edge-vertex-connectivity.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Độ liên thông cạnh / Độ liên thông đỉnh
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/tree-painting.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tô màu cây
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/2-sat.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2-SAT
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/hld.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Heavy-light decomposition (HLD)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          <label class="md-nav__link" for="__nav_11" id="__nav_11_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Khác
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            
  
    Khác
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11_1" >
        
          
          <label class="md-nav__link" for="__nav_11_1" id="__nav_11_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Dãy số
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_11_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Dãy số
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../sequences/rmq.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bài toán RMQ (Range Minimum Query - phần tử nhỏ nhất trong đoạn)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../others/maximum-average-segment.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm đoạn con có tổng lớn nhất/nhỏ nhất
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../sequences/k-th.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tìm thống kê thứ K trong O(N)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../sequences/mex.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bài toán MEX (Phần tử nhỏ nhất không xuất hiện)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11_2" >
        
          
          <label class="md-nav__link" for="__nav_11_2" id="__nav_11_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Lý thuyết trò chơi
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_11_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Lý thuyết trò chơi
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../game_theory/games-on-graphs.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Trò chơi trên đồ thị bất kỳ
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../game_theory/sprague-grundy-nim.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Định lý Sprague-Grundy. Trò chơi Nim
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11_3" >
        
          
          <label class="md-nav__link" for="__nav_11_3" id="__nav_11_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Lập lịch
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_11_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Lập lịch
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../schedules/schedule-one-machine.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Lập lịch trên một máy
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../schedules/schedule-two-machines.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Lập lịch trên hai máy
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../schedules/schedule-with-completion-duration.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Lịch tối ưu với deadline và thời lượng
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11_4" >
        
          
          <label class="md-nav__link" for="__nav_11_4" id="__nav_11_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Khác
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_11_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Khác
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../others/tortoise-and-hare.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Thuật toán Rùa và Thỏ (Phát hiện chu trình trong danh sách liên kết)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../others/josephus-problem.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bài toán Josephus
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../others/15-puzzle.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Trò chơi 15 Puzzle: Sự tồn tại của lời giải
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../others/stern-brocot-tree-farey-sequences.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Cây Stern-Brocot và Dãy Farey
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  <script type="text/javascript">
  window.onload = function () {
    const newIssueURL = "https://github.com/cp-algorithms/cp-algorithms/issues/new";
    const issueTitle = "Problem on article " + "Segment Tree";
  const issueBody = `
**Article:** [`+ "Segment Tree" + `](${window.location.href})

**Problem:**
`;
  var issue_a = document.getElementById("report_issue_a");
  if (issue_a) {
    issue_a.href = `${newIssueURL}?` + `title=${encodeURIComponent(issueTitle)}&` + `body=${encodeURIComponent(issueBody)}`;
  }
}
</script>


<a href="https://github.com/deanqkhanhcoder/cp-algorithms-vi/edit/main/src/data_structures/segment-tree.md" title="Edit this page" class="md-content__button md-icon">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75z"/></svg>
</a>
<a id="report_issue_a" href="" title="Report a problem" class="md-content__button md-icon">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14h-2V9h2m0 9h-2v-2h2M1 21h22L12 2z"/></svg>
</a>


<ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr">
  
  
  <a href="../tags.html#tag:translated" class="md-tag">
    Translated
  </a>
  
  

  
  
  
  
  <a href="https://e-maxx.ru/algo/segment_tree" class="md-tag">From: e-maxx.ru</a>
  
  
</ul>


<h1 id="segment-tree">Cây phân đoạn (Segment Tree)<a class="headerlink" href="#segment-tree" title="Permanent link">&para;</a></h1>
<p>Segment Tree (Cây phân đoạn) là một cấu trúc dữ liệu lưu trữ thông tin về các khoảng của mảng dưới dạng cây. Điều này cho phép trả lời các truy vấn đoạn trên một mảng một cách hiệu quả, trong khi vẫn đủ linh hoạt để cho phép sửa đổi nhanh mảng.
Điều này bao gồm việc tìm tổng của các phần tử mảng liên tiếp <span class="arithmatex">$a[l \dots r]$</span>, hoặc tìm phần tử nhỏ nhất trong một đoạn như vậy trong thời gian <span class="arithmatex">$O(\log n)$</span>.
Giữa việc trả lời các truy vấn như vậy, Segment Tree cho phép sửa đổi mảng bằng cách thay thế một phần tử, hoặc thậm chí thay đổi các phần tử của cả một đoạn con (ví dụ: gán tất cả các phần tử <span class="arithmatex">$a[l \dots r]$</span> cho bất kỳ giá trị nào, hoặc thêm một giá trị vào tất cả các phần tử trong đoạn con).</p>
<p>Nhìn chung, Segment Tree là một cấu trúc dữ liệu rất linh hoạt, và một số lượng lớn các bài toán có thể được giải quyết bằng nó.
Ngoài ra, cũng có thể áp dụng các thao tác phức tạp hơn và trả lời các truy vấn phức tạp hơn (xem <a href="#advanced-versions-of-segment-trees">Các phiên bản nâng cao của Segment Trees</a>).
Đặc biệt, Segment Tree có thể dễ dàng được khái quát hóa cho các chiều lớn hơn.
Ví dụ, với Segment Tree hai chiều, bạn có thể trả lời các truy vấn tổng hoặc giá trị nhỏ nhất trên một hình chữ nhật con của một ma trận đã cho chỉ trong thời gian <span class="arithmatex">$O(\log^2 n)$</span>.</p>
<p>Một tính chất quan trọng của Segment Trees là chúng chỉ yêu cầu một lượng bộ nhớ tuyến tính.
Segment Tree tiêu chuẩn cần <span class="arithmatex">$4n$</span> nút để làm việc trên một mảng có kích thước <span class="arithmatex">$n$</span>.</p>
<h2 id="simplest-form-of-a-segment-tree">Dạng đơn giản nhất của Segment Tree (Simplest form of a Segment Tree)<a class="headerlink" href="#simplest-form-of-a-segment-tree" title="Permanent link">&para;</a></h2>
<p>Để bắt đầu dễ dàng, chúng ta xem xét dạng đơn giản nhất của Segment Tree.
Chúng ta muốn trả lời các truy vấn tổng một cách hiệu quả.
Định nghĩa chính thức của nhiệm vụ của chúng ta là:
Cho một mảng <span class="arithmatex">$a[0 \dots n-1]$</span>, Segment Tree phải có khả năng tìm tổng của các phần tử giữa các chỉ số <span class="arithmatex">$l$</span> và <span class="arithmatex">$r$</span> (tức là tính tổng <span class="arithmatex">$\sum_{i=l}^r a[i]$</span>), và cũng xử lý việc thay đổi giá trị của các phần tử trong mảng (tức là thực hiện các phép gán có dạng <span class="arithmatex">$a[i] = x$</span>).
Segment Tree phải có khả năng xử lý <strong>cả hai</strong> truy vấn trong thời gian <span class="arithmatex">$O(\log n)$</span>.</p>
<p>Đây là một sự cải tiến so với các cách tiếp cận đơn giản hơn.
Một cách cài đặt mảng đơn giản - chỉ sử dụng một mảng đơn giản - có thể cập nhật các phần tử trong <span class="arithmatex">$O(1)$</span>, nhưng yêu cầu <span class="arithmatex">$O(n)$</span> để tính toán từng truy vấn tổng.
Và tổng tiền tố được tính toán trước có thể tính toán các truy vấn tổng trong <span class="arithmatex">$O(1)$</span>, nhưng việc cập nhật một phần tử mảng yêu cầu <span class="arithmatex">$O(n)$</span> thay đổi đối với tổng tiền tố.</p>
<h3 id="structure-of-the-segment-tree">Cấu trúc của Segment Tree (Structure of the Segment Tree)<a class="headerlink" href="#structure-of-the-segment-tree" title="Permanent link">&para;</a></h3>
<p>Chúng ta có thể thực hiện cách tiếp cận chia để trị khi nói đến các đoạn mảng.
Chúng ta tính toán và lưu trữ tổng của các phần tử của toàn bộ mảng, tức là tổng của đoạn <span class="arithmatex">$a[0 \dots n-1]$</span>.
Sau đó, chúng ta chia mảng thành hai nửa <span class="arithmatex">$a[0 \dots (n-1)/2]$</span> và <span class="arithmatex">$a[(n+1)/2 \dots n-1]$</span> và tính tổng của mỗi nửa và lưu trữ chúng.
Mỗi nửa trong hai nửa này lần lượt được chia đôi, và cứ thế cho đến khi tất cả các đoạn đạt kích thước <span class="arithmatex">$1$</span>.</p>
<p>Chúng ta có thể xem các đoạn này tạo thành một cây nhị phân:
gốc của cây này là đoạn <span class="arithmatex">$a[0 \dots n-1]$</span>, và mỗi nút (trừ các nút lá) có chính xác hai nút con.
Đây là lý do tại sao cấu trúc dữ liệu được gọi là "Segment Tree", mặc dù trong hầu hết các triển khai, cây không được xây dựng một cách rõ ràng (xem <a href="#implementation">Cài đặt</a>).</p>
<p>Dưới đây là một biểu diễn trực quan của một Segment Tree như vậy trên mảng <span class="arithmatex">$a = [1, 3, -2, 8, -7]$</span>:</p>
<p><img alt="&quot;Sum Segment Tree&quot;" src="../assets/images/sum-segment-tree.png" /></p>
<p>Từ mô tả ngắn gọn này về cấu trúc dữ liệu, chúng ta đã có thể kết luận rằng một Segment Tree chỉ yêu cầu một số lượng nút tuyến tính.
Cấp đầu tiên của cây chứa một nút duy nhất (gốc), cấp thứ hai sẽ chứa hai nút, trong cấp thứ ba nó sẽ chứa bốn nút, cho đến khi số lượng nút đạt <span class="arithmatex">$n$</span>.
Do đó, số lượng nút trong trường hợp xấu nhất có thể được ước tính bằng tổng <span class="arithmatex">$1 + 2 + 4 + \dots + 2^{\lceil\log_2 n\rceil} \lt 2^{\lceil\log_2 n\rceil + 1} \lt 4n$</span>.</p>
<p>Điều đáng chú ý là bất cứ khi nào <span class="arithmatex">$n$</span> không phải là lũy thừa của hai, không phải tất cả các cấp của Segment Tree sẽ được lấp đầy hoàn toàn.
Chúng ta có thể thấy hành vi đó trong hình ảnh.
Bây giờ chúng ta có thể quên đi thực tế này, nhưng nó sẽ trở nên quan trọng sau này trong quá trình cài đặt.</p>
<p>Chiều cao của Segment Tree là <span class="arithmatex">$O(\log n)$</span>, bởi vì khi đi xuống từ gốc đến các lá, kích thước của các đoạn giảm khoảng một nửa.</p>
<h3 id="construction">Xây dựng (Construction)<a class="headerlink" href="#construction" title="Permanent link">&para;</a></h3>
<p>Trước khi xây dựng segment tree, chúng ta cần quyết định:</p>
<ol>
<li><em>giá trị</em> được lưu trữ tại mỗi nút của segment tree.
    Ví dụ, trong một segment tree tổng, một nút sẽ lưu trữ tổng của các phần tử trong phạm vi <span class="arithmatex">$[l, r]$</span> của nó.</li>
<li>thao tác <em>hợp nhất</em> (merge) kết hợp hai anh em trong một segment tree.
    Ví dụ, trong một segment tree tổng, hai nút tương ứng với các phạm vi <span class="arithmatex">$a[l_1 \dots r_1]$</span> và <span class="arithmatex">$a[l_2 \dots r_2]$</span> sẽ được hợp nhất thành một nút tương ứng với phạm vi <span class="arithmatex">$a[l_1 \dots r_2]$</span> bằng cách cộng các giá trị của hai nút.</li>
</ol>
<p>Lưu ý rằng một nút là một "nút lá", nếu đoạn tương ứng của nó chỉ bao gồm một giá trị trong mảng ban đầu. Nó có mặt ở cấp thấp nhất của một segment tree. Giá trị của nó sẽ bằng phần tử (tương ứng) <span class="arithmatex">$a[i]$</span>.</p>
<p>Bây giờ, để xây dựng segment tree, chúng ta bắt đầu ở cấp dưới cùng (các nút lá) và gán cho chúng các giá trị tương ứng. Trên cơ sở các giá trị này, chúng ta có thể tính toán các giá trị của cấp trước đó, bằng cách sử dụng hàm <code>merge</code>.
Và trên cơ sở đó, chúng ta có thể tính toán các giá trị của cấp trước nữa, và lặp lại quy trình cho đến khi chúng ta đến nút gốc.</p>
<p>Thuận tiện để mô tả thao tác này một cách đệ quy theo hướng khác, tức là, từ nút gốc đến các nút lá. Thủ tục xây dựng, nếu được gọi trên một nút không phải lá, thực hiện như sau:</p>
<ol>
<li>xây dựng đệ quy các giá trị của hai nút con</li>
<li>hợp nhất các giá trị đã tính toán của các con này.</li>
</ol>
<p>Chúng ta bắt đầu xây dựng tại nút gốc, và do đó, chúng ta có thể tính toán toàn bộ segment tree.</p>
<p>Độ phức tạp thời gian của việc xây dựng này là <span class="arithmatex">$O(n)$</span>, giả sử rằng thao tác hợp nhất là thời gian hằng số (thao tác hợp nhất được gọi <span class="arithmatex">$n$</span> lần, bằng số lượng các nút bên trong segment tree).</p>
<h3 id="sum-queries">Truy vấn tổng (Sum queries)<a class="headerlink" href="#sum-queries" title="Permanent link">&para;</a></h3>
<p>Bây giờ chúng ta sẽ trả lời các truy vấn tổng. Là đầu vào, chúng ta nhận được hai số nguyên <span class="arithmatex">$l$</span> và <span class="arithmatex">$r$</span>, và chúng ta phải tính tổng của đoạn <span class="arithmatex">$a[l \dots r]$</span> trong thời gian <span class="arithmatex">$O(\log n)$</span>.</p>
<p>Để làm điều này, chúng ta sẽ duyệt qua Segment Tree và sử dụng các tổng đã tính toán trước của các đoạn.
Giả sử rằng chúng ta hiện đang ở nút bao gồm đoạn <span class="arithmatex">$a[tl \dots tr]$</span>.
Có ba trường hợp có thể xảy ra.</p>
<p>Trường hợp dễ nhất là khi đoạn <span class="arithmatex">$a[l \dots r]$</span> bằng với đoạn tương ứng của nút hiện tại (tức là <span class="arithmatex">$a[l \dots r] = a[tl \dots tr]$</span>), thì chúng ta đã hoàn thành và có thể trả về tổng đã tính toán trước được lưu trữ trong nút.</p>
<p>Ngoài ra, đoạn của truy vấn có thể rơi hoàn toàn vào miền của con trái hoặc con phải.
Hãy nhớ lại rằng con trái bao gồm đoạn <span class="arithmatex">$a[tl \dots tm]$</span> và nút phải bao gồm đoạn <span class="arithmatex">$a[tm + 1 \dots tr]$</span> với <span class="arithmatex">$tm = (tl + tr) / 2$</span>.
Trong trường hợp này, chúng ta chỉ cần đi đến nút con, mà đoạn tương ứng bao gồm đoạn truy vấn, và thực thi thuật toán được mô tả ở đây với nút đó.</p>
<p>Và sau đó là trường hợp cuối cùng, đoạn truy vấn giao với cả hai con.
Trong trường hợp này, chúng ta không có lựa chọn nào khác ngoài việc thực hiện hai cuộc gọi đệ quy, một cho mỗi con.
Đầu tiên chúng ta đi đến con trái, tính toán câu trả lời một phần cho nút này (tức là tổng các giá trị của phần giao nhau giữa đoạn của truy vấn và đoạn của con trái), sau đó đi đến con phải, tính toán câu trả lời một phần bằng nút đó, và sau đó kết hợp các câu trả lời bằng cách cộng chúng lại.
Nói cách khác, vì con trái đại diện cho đoạn <span class="arithmatex">$a[tl \dots tm]$</span> và con phải đại diện cho đoạn <span class="arithmatex">$a[tm+1 \dots tr]$</span>, chúng ta tính toán truy vấn tổng <span class="arithmatex">$a[l \dots tm]$</span> bằng cách sử dụng con trái, và truy vấn tổng <span class="arithmatex">$a[tm+1 \dots r]$</span> bằng cách sử dụng con phải.</p>
<p>Vì vậy, xử lý truy vấn tổng là một hàm đệ quy tự gọi chính nó một lần với con trái hoặc con phải (không thay đổi ranh giới truy vấn), hoặc hai lần, một lần cho con trái và một lần cho con phải (bằng cách chia truy vấn thành hai truy vấn con).
Và đệ quy kết thúc, bất cứ khi nào ranh giới của đoạn truy vấn hiện tại trùng với ranh giới của đoạn của nút hiện tại.
Trong trường hợp đó, câu trả lời sẽ là giá trị đã tính toán trước của tổng của đoạn này, được lưu trữ trong cây.</p>
<p>Nói cách khác, việc tính toán truy vấn là một quá trình duyệt cây, lan truyền qua tất cả các nhánh cần thiết của cây, và sử dụng các giá trị tổng đã tính toán trước của các đoạn trong cây.</p>
<p>Rõ ràng chúng ta sẽ bắt đầu duyệt từ nút gốc của Segment Tree.</p>
<p>Thủ tục được minh họa trong hình ảnh sau.
Một lần nữa mảng <span class="arithmatex">$a = [1, 3, -2, 8, -7]$</span> được sử dụng, và ở đây chúng ta muốn tính tổng <span class="arithmatex">$\sum_{i=2}^4 a[i]$</span>.
Các nút có màu sẽ được truy cập, và chúng ta sẽ sử dụng các giá trị đã tính toán trước của các nút màu xanh lá cây.
Điều này cho chúng ta kết quả <span class="arithmatex">$-2 + 1 = -1$</span>.</p>
<p><img alt="&quot;Sum Segment Tree Query&quot;" src="../assets/images/sum-segment-tree-query.png" /></p>
<p>Tại sao độ phức tạp của thuật toán này là <span class="arithmatex">$O(\log n)$</span>?
Để hiển thị độ phức tạp này, chúng ta xem xét từng cấp của cây.
Hóa ra, đối với mỗi cấp, chúng ta chỉ truy cập không quá bốn nút.
Và vì chiều cao của cây là <span class="arithmatex">$O(\log n)$</span>, chúng ta nhận được thời gian chạy mong muốn.</p>
<p>Chúng ta có thể chứng minh rằng mệnh đề này (tối đa bốn nút mỗi cấp) là đúng bằng quy nạp.
Ở cấp độ đầu tiên, chúng ta chỉ truy cập một nút, nút gốc, vì vậy ở đây chúng ta truy cập ít hơn bốn nút.
Bây giờ hãy nhìn vào một cấp độ tùy ý.
Theo giả thuyết quy nạp, chúng ta truy cập tối đa bốn nút.
Nếu chúng ta chỉ truy cập tối đa hai nút, cấp độ tiếp theo có tối đa bốn nút. Điều đó là tầm thường, bởi vì mỗi nút chỉ có thể gây ra tối đa hai cuộc gọi đệ quy.
Vì vậy, hãy giả sử rằng chúng ta truy cập ba hoặc bốn nút trong cấp độ hiện tại.
Từ những nút đó, chúng ta sẽ phân tích các nút ở giữa cẩn thận hơn.
Vì truy vấn tổng yêu cầu tổng của một mảng con liên tục, chúng ta biết rằng các đoạn tương ứng với các nút được truy cập ở giữa sẽ được bao phủ hoàn toàn bởi đoạn của truy vấn tổng.
Do đó, các nút này sẽ không thực hiện bất kỳ cuộc gọi đệ quy nào.
Vì vậy, chỉ có nút ngoài cùng bên trái và nút ngoài cùng bên phải mới có tiềm năng thực hiện các cuộc gọi đệ quy.
Và những nút đó sẽ chỉ tạo ra tối đa bốn cuộc gọi đệ quy, vì vậy cấp độ tiếp theo cũng sẽ thỏa mãn khẳng định.
Chúng ta có thể nói rằng một nhánh tiếp cận ranh giới bên trái của truy vấn, và nhánh thứ hai tiếp cận ranh giới bên phải.</p>
<p>Do đó, chúng ta truy cập tối đa <span class="arithmatex">$4 \log n$</span> nút trong tổng số, và điều đó bằng với thời gian chạy là <span class="arithmatex">$O(\log n)$</span>.</p>
<p>Tóm lại, truy vấn hoạt động bằng cách chia đoạn đầu vào thành nhiều đoạn con mà tất cả các tổng đã được tính toán trước và lưu trữ trong cây.
Và nếu chúng ta ngừng phân chia bất cứ khi nào đoạn truy vấn trùng với đoạn nút, thì chúng ta chỉ cần <span class="arithmatex">$O(\log n)$</span> đoạn như vậy, điều này mang lại hiệu quả của Segment Tree.</p>
<h3 id="update-queries">Truy vấn cập nhật (Update queries)<a class="headerlink" href="#update-queries" title="Permanent link">&para;</a></h3>
<p>Bây giờ chúng ta muốn sửa đổi một phần tử cụ thể trong mảng, giả sử chúng ta muốn thực hiện phép gán <span class="arithmatex">$a[i] = x$</span>.
Và chúng ta phải xây dựng lại Segment Tree, sao cho nó tương ứng với mảng mới, đã sửa đổi.</p>
<p>Truy vấn này dễ hơn truy vấn tổng.
Mỗi cấp của một Segment Tree tạo thành một phân vùng của mảng.
Do đó, một phần tử <span class="arithmatex">$a[i]$</span> chỉ đóng góp vào một đoạn từ mỗi cấp.
Do đó chỉ có <span class="arithmatex">$O(\log n)$</span> nút cần được cập nhật.</p>
<p>Dễ thấy rằng, yêu cầu cập nhật có thể được thực hiện bằng cách sử dụng một hàm đệ quy.
Hàm được chuyển qua nút cây hiện tại, và nó gọi đệ quy chính nó với một trong hai nút con (nút chứa <span class="arithmatex">$a[i]$</span> trong đoạn của nó), và sau đó tính toán lại giá trị tổng của nó, tương tự như cách nó được thực hiện trong phương thức build (đó là tổng của hai con của nó).</p>
<p>Một lần nữa đây là một hình ảnh trực quan sử dụng cùng một mảng.
Ở đây chúng ta thực hiện cập nhật <span class="arithmatex">$a[2] = 3$</span>.
Các nút màu xanh lá cây là các nút mà chúng ta truy cập và cập nhật.</p>
<p><img alt="&quot;Sum Segment Tree Update&quot;" src="../assets/images/sum-segment-tree-update.png" /></p>
<h3 id="implementation">Cài đặt (Implementation)<a class="headerlink" href="#implementation" title="Permanent link">&para;</a></h3>
<p>Cân nhắc chính là cách lưu trữ Segment Tree.
Tất nhiên chúng ta có thể định nghĩa một struct <span class="arithmatex">$\text{Vertex}$</span> và tạo các đối tượng, lưu trữ các ranh giới của đoạn, tổng của nó và thêm vào đó là các con trỏ đến các nút con của nó.
Tuy nhiên, điều này đòi hỏi phải lưu trữ rất nhiều thông tin dư thừa dưới dạng các con trỏ.
Chúng ta sẽ sử dụng một thủ thuật đơn giản để làm cho việc này hiệu quả hơn nhiều bằng cách sử dụng một <em>cấu trúc dữ liệu ẩn</em> (<em>implicit data structure</em>): Chỉ lưu trữ các tổng trong một mảng.
(Một phương pháp tương tự được sử dụng cho binary heaps).
Tổng của nút gốc tại chỉ số 1, tổng của hai nút con của nó tại các chỉ số 2 và 3, tổng của các con của hai nút đó tại các chỉ số 4 đến 7, v.v.
Với chỉ số bắt đầu từ 1, thuận tiện là con trái của một nút tại chỉ số <span class="arithmatex">$i$</span> được lưu trữ tại chỉ số <span class="arithmatex">$2i$</span>, và con phải tại chỉ số <span class="arithmatex">$2i + 1$</span>.
Tương đương, cha của một nút tại chỉ số <span class="arithmatex">$i$</span> được lưu trữ tại <span class="arithmatex">$i/2$</span> (phép chia số nguyên).</p>
<p>Điều này đơn giản hóa việc cài đặt rất nhiều.
Chúng ta không cần lưu trữ cấu trúc của cây trong bộ nhớ.
Nó được định nghĩa ngầm.
Chúng ta chỉ cần một mảng chứa tổng của tất cả các đoạn.</p>
<p>Như đã lưu ý trước đây, chúng ta cần lưu trữ tối đa <span class="arithmatex">$4n$</span> nút.
Nó có thể ít hơn, nhưng để thuận tiện chúng ta luôn cấp phát một mảng có kích thước <span class="arithmatex">$4n$</span>.
Sẽ có một số phần tử trong mảng tổng, sẽ không tương ứng với bất kỳ nút nào trong cây thực tế, nhưng điều này không làm phức tạp việc cài đặt.</p>
<p>Vì vậy, chúng ta lưu trữ Segment Tree đơn giản dưới dạng một mảng <span class="arithmatex">$t[]$</span> với kích thước gấp bốn lần kích thước đầu vào <span class="arithmatex">$n$</span>:
<div class="highlight"><span class="filename">segment_tree_implementation_definition</span><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">MAXN</span><span class="p">];</span>
</code></pre></div></p>
<p>Thủ tục xây dựng Segment Tree từ một mảng <span class="arithmatex">$a[]$</span> đã cho trông như thế này:
nó là một hàm đệ quy với các tham số <span class="arithmatex">$a[]$</span> (mảng đầu vào), <span class="arithmatex">$v$</span> (chỉ số của nút hiện tại), và các ranh giới <span class="arithmatex">$tl$</span> và <span class="arithmatex">$tr$</span> của đoạn hiện tại.
Trong chương trình chính, hàm này sẽ được gọi với các tham số của nút gốc: <span class="arithmatex">$v = 1$</span>, <span class="arithmatex">$tl = 0$</span>, và <span class="arithmatex">$tr = n - 1$</span>.
<div class="highlight"><span class="filename">segment_tree_implementation_build</span><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">);</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Hơn nữa, hàm để trả lời các truy vấn tổng cũng là một hàm đệ quy, nhận các tham số thông tin về nút/đoạn hiện tại (tức là chỉ số <span class="arithmatex">$v$</span> và các ranh giới <span class="arithmatex">$tl$</span> và <span class="arithmatex">$tr$</span>) và cả thông tin về các ranh giới của truy vấn, <span class="arithmatex">$l$</span> và <span class="arithmatex">$r$</span>.
Để đơn giản hóa mã, hàm này luôn thực hiện hai cuộc gọi đệ quy, ngay cả khi chỉ cần một - trong trường hợp đó, cuộc gọi đệ quy thừa sẽ có <span class="arithmatex">$l &gt; r$</span>, và điều này có thể dễ dàng bị bắt bằng cách sử dụng một kiểm tra bổ sung ở đầu hàm.
<div class="highlight"><span class="filename">segment_tree_implementation_sum</span><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">))</span>
<span class="w">           </span><span class="o">+</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Cuối cùng là truy vấn cập nhật. Hàm cũng sẽ nhận thông tin về nút/đoạn hiện tại, và thêm vào đó là tham số của truy vấn cập nhật (tức là vị trí của phần tử và giá trị mới của nó).
<div class="highlight"><span class="filename">segment_tree_implementation_update</span><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_val</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="memory-efficient-implementation">Cài đặt hiệu quả bộ nhớ (Memory efficient implementation)<a class="headerlink" href="#memory-efficient-implementation" title="Permanent link">&para;</a></h3>
<p>Hầu hết mọi người sử dụng cài đặt từ phần trước. Nếu bạn nhìn vào mảng <code>t</code> bạn có thể thấy rằng nó tuân theo việc đánh số các nút cây theo thứ tự duyệt BFS (duyệt theo cấp - level-order traversal).
Sử dụng cách duyệt này, các con của nút <span class="arithmatex">$v$</span> lần lượt là <span class="arithmatex">$2v$</span> và <span class="arithmatex">$2v + 1$</span>.
Tuy nhiên, nếu <span class="arithmatex">$n$</span> không phải là lũy thừa của hai, phương pháp này sẽ bỏ qua một số chỉ số và để lại một số phần của mảng <code>t</code> không được sử dụng.
Mức tiêu thụ bộ nhớ bị giới hạn bởi <span class="arithmatex">$4n$</span>, mặc dù một Segment Tree của một mảng <span class="arithmatex">$n$</span> phần tử chỉ yêu cầu <span class="arithmatex">$2n - 1$</span> nút.</p>
<p>Tuy nhiên nó có thể giảm được.
Chúng ta đánh số lại các nút của cây theo thứ tự duyệt Euler tour (duyệt tiền thứ tự - pre-order traversal), và chúng ta viết tất cả các nút này cạnh nhau.</p>
<p>Hãy xem xét một nút tại chỉ số <span class="arithmatex">$v$</span>, và để nó quản lý đoạn <span class="arithmatex">$[l, r]$</span>, và đặt <span class="arithmatex">$mid = \dfrac{l + r}{2}$</span>.
Rõ ràng là con trái sẽ có chỉ số <span class="arithmatex">$v + 1$</span>.
Con trái quản lý đoạn <span class="arithmatex">$[l, mid]$</span>, tức là tổng cộng sẽ có <span class="arithmatex">$2 * (mid - l + 1) - 1$</span> nút trong cây con của con trái.
Do đó, chúng ta có thể tính toán chỉ số của con phải của <span class="arithmatex">$v$</span>. Chỉ số sẽ là <span class="arithmatex">$v + 2 * (mid - l + 1)$</span>.
Bằng cách đánh số này, chúng ta đạt được sự sụt giảm bộ nhớ cần thiết xuống <span class="arithmatex">$2n$</span>.</p>
<h2 id="advanced-versions-of-segment-trees">Các phiên bản nâng cao của Segment Trees (Advanced versions of Segment Trees)<a class="headerlink" href="#advanced-versions-of-segment-trees" title="Permanent link">&para;</a></h2>
<p>Một Segment Tree là một cấu trúc dữ liệu rất linh hoạt, và cho phép các biến thể và mở rộng theo nhiều hướng khác nhau.
Hãy thử phân loại chúng dưới đây.</p>
<h3 id="more-complex-queries">Các truy vấn phức tạp hơn (More complex queries)<a class="headerlink" href="#more-complex-queries" title="Permanent link">&para;</a></h3>
<p>Có thể khá dễ dàng để thay đổi Segment Tree theo một hướng, sao cho nó tính toán các truy vấn khác nhau (ví dụ: tính toán giá trị nhỏ nhất / lớn nhất thay vì tổng), nhưng nó cũng có thể rất không đơn giản.</p>
<h4 id="finding-the-maximum">Tìm giá trị lớn nhất (Finding the maximum)<a class="headerlink" href="#finding-the-maximum" title="Permanent link">&para;</a></h4>
<p>Chúng ta hãy thay đổi nhẹ điều kiện của bài toán được mô tả ở trên: thay vì truy vấn tổng, bây giờ chúng ta sẽ thực hiện các truy vấn giá trị lớn nhất.</p>
<p>Cây sẽ có cấu trúc chính xác giống như cây được mô tả ở trên.
Chúng ta chỉ cần thay đổi cách tính <span class="arithmatex">$t[v]$</span> trong các hàm <span class="arithmatex">$\text{build}$</span> và <span class="arithmatex">$\text{update}$</span>.
<span class="arithmatex">$t[v]$</span> bây giờ sẽ lưu trữ giá trị lớn nhất của đoạn tương ứng.
Và chúng ta cũng cần thay đổi việc tính toán giá trị trả về của hàm <span class="arithmatex">$\text{sum}$</span> (thay thế phép cộng bằng giá trị lớn nhất).</p>
<p>Tất nhiên bài toán này có thể dễ dàng thay đổi thành việc tính toán giá trị nhỏ nhất thay vì giá trị lớn nhất.</p>
<p>Thay vì hiển thị một cài đặt cho bài toán này, cài đặt sẽ được đưa ra cho một phiên bản phức tạp hơn của bài toán này trong phần tiếp theo.</p>
<h4 id="finding-the-maximum-and-the-number-of-times-it-appears">Tìm giá trị lớn nhất và số lần xuất hiện của nó (Finding the maximum and the number of times it appears)<a class="headerlink" href="#finding-the-maximum-and-the-number-of-times-it-appears" title="Permanent link">&para;</a></h4>
<p>Nhiệm vụ này rất giống với nhiệm vụ trước.
Ngoài việc tìm giá trị lớn nhất, chúng ta cũng phải tìm số lần xuất hiện của nó.</p>
<p>Để giải quyết bài toán này, chúng ta lưu trữ một cặp số tại mỗi nút trong cây:
Ngoài giá trị lớn nhất, chúng ta cũng lưu trữ số lần xuất hiện của nó trong đoạn tương ứng.
Việc xác định cặp chính xác để lưu trữ tại <span class="arithmatex">$t[v]$</span> vẫn có thể được thực hiện trong thời gian hằng số bằng cách sử dụng thông tin của các cặp được lưu trữ tại các nút con.
Việc kết hợp hai cặp như vậy nên được thực hiện trong một hàm riêng biệt, vì đây sẽ là một thao tác mà chúng ta sẽ làm trong khi xây dựng cây, trong khi trả lời các truy vấn giá trị lớn nhất và trong khi thực hiện các sửa đổi.
<div class="highlight"><span class="filename">segment_tree_maximum_and_count</span><pre><span></span><code><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">MAXN</span><span class="p">];</span>

<span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">make_pair</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_pair</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">);</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_max</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">make_pair</span><span class="p">(</span><span class="o">-</span><span class="n">INF</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">get_max</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">)),</span><span class="w"> </span>
<span class="w">                   </span><span class="n">get_max</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_pair</span><span class="p">(</span><span class="n">new_val</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<h4 id="compute-the-greatest-common-divisor-least-common-multiple">Tính ước chung lớn nhất / bội chung nhỏ nhất (Compute the greatest common divisor / least common multiple)<a class="headerlink" href="#compute-the-greatest-common-divisor-least-common-multiple" title="Permanent link">&para;</a></h4>
<p>Trong bài toán này, chúng ta muốn tính GCD / LCM của tất cả các số trong các phạm vi đã cho của mảng.</p>
<p>Biến thể thú vị này của Segment Tree có thể được giải quyết theo cách chính xác giống như các Segment Trees mà chúng ta đã suy ra cho các truy vấn tổng / giá trị nhỏ nhất / giá trị lớn nhất:
chỉ cần lưu trữ GCD / LCM của nút tương ứng trong mỗi nút của cây.
Việc kết hợp hai nút có thể được thực hiện bằng cách tính GCD / LCM của cả hai nút.</p>
<h4 id="counting-zero-search-kth">Đếm số lượng số 0, tìm số 0 thứ <span class="arithmatex">$k$</span> (Counting the number of zeros, searching for the k-th zero)<a class="headerlink" href="#counting-zero-search-kth" title="Permanent link">&para;</a></h4>
<p>Trong bài toán này, chúng ta muốn tìm số lượng số 0 trong một đoạn đã cho, và tìm thêm chỉ số của số 0 thứ <span class="arithmatex">$k$</span> bằng cách sử dụng một hàm thứ hai.</p>
<p>Một lần nữa, chúng ta phải thay đổi các giá trị lưu trữ của cây một chút:
Lần này chúng ta sẽ lưu trữ số lượng số 0 trong mỗi đoạn trong <span class="arithmatex">$t[]$</span>.
Khá rõ ràng về cách cài đặt các hàm <span class="arithmatex">$\text{build}$</span>, <span class="arithmatex">$\text{update}$</span> và <span class="arithmatex">$\text{count_zero}$</span>, chúng ta chỉ cần sử dụng các ý tưởng từ bài toán truy vấn tổng.
Do đó, chúng ta đã giải quyết phần đầu tiên của bài toán.</p>
<p>Bây giờ chúng ta học cách giải quyết bài toán tìm số 0 thứ <span class="arithmatex">$k$</span> trong mảng <span class="arithmatex">$a[]$</span>.
Để thực hiện nhiệm vụ này, chúng ta sẽ đi xuống Segment Tree, bắt đầu từ nút gốc, và di chuyển mỗi lần sang con trái hoặc con phải, tùy thuộc vào việc đoạn nào chứa số 0 thứ <span class="arithmatex">$k$</span>.
Để quyết định chúng ta cần đi đến con nào, chỉ cần nhìn vào số lượng số 0 xuất hiện trong đoạn tương ứng với nút trái.
Nếu số đếm đã tính toán trước này lớn hơn hoặc bằng <span class="arithmatex">$k$</span>, cần phải đi xuống con trái, và ngược lại đi xuống con phải.
Lưu ý, nếu chúng ta chọn con phải, chúng ta phải trừ số lượng số 0 của con trái khỏi <span class="arithmatex">$k$</span>.</p>
<p>Trong việc cài đặt, chúng ta có thể xử lý trường hợp đặc biệt, <span class="arithmatex">$a[]$</span> chứa ít hơn <span class="arithmatex">$k$</span> số 0, bằng cách trả về -1.
<div class="highlight"><span class="filename">segment_tree_kth_zero</span><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">find_kth</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">tl</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">find_kth</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">find_kth</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></p>
<h4 id="searching-for-an-array-prefix-with-a-given-amount">Tìm kiếm tiền tố mảng với một lượng nhất định (Searching for an array prefix with a given amount)<a class="headerlink" href="#searching-for-an-array-prefix-with-a-given-amount" title="Permanent link">&para;</a></h4>
<p>Nhiệm vụ như sau:
đối với một giá trị <span class="arithmatex">$x$</span> đã cho, chúng ta phải nhanh chóng tìm chỉ số nhỏ nhất <span class="arithmatex">$i$</span> sao cho tổng của <span class="arithmatex">$i$</span> phần tử đầu tiên của mảng <span class="arithmatex">$a[]$</span> lớn hơn hoặc bằng <span class="arithmatex">$x$</span> (giả sử rằng mảng <span class="arithmatex">$a[]$</span> chỉ chứa các giá trị không âm).</p>
<p>Nhiệm vụ này có thể được giải quyết bằng cách sử dụng tìm kiếm nhị phân, tính tổng của các tiền tố bằng Segment Tree.
Tuy nhiên điều này sẽ dẫn đến một giải pháp <span class="arithmatex">$O(\log^2 n)$</span>.</p>
<p>Thay vào đó, chúng ta có thể sử dụng cùng một ý tưởng như trong phần trước, và tìm vị trí bằng cách đi xuống cây:
bằng cách di chuyển mỗi lần sang trái hoặc phải, tùy thuộc vào tổng của con trái.
Do đó tìm thấy câu trả lời trong thời gian <span class="arithmatex">$O(\log n)$</span>.</p>
<h4 id="searching-for-the-first-element-greater-than-a-given-amount">Tìm kiếm phần tử đầu tiên lớn hơn một lượng nhất định (Searching for the first element greater than a given amount)<a class="headerlink" href="#searching-for-the-first-element-greater-than-a-given-amount" title="Permanent link">&para;</a></h4>
<p>Nhiệm vụ như sau:
đối với một giá trị <span class="arithmatex">$x$</span> đã cho và một đoạn <span class="arithmatex">$a[l \dots r]$</span>, tìm <span class="arithmatex">$i$</span> nhỏ nhất trong đoạn <span class="arithmatex">$a[l \dots r]$</span>, sao cho <span class="arithmatex">$a[i]$</span> lớn hơn <span class="arithmatex">$x$</span>.</p>
<p>Nhiệm vụ này có thể được giải quyết bằng cách sử dụng tìm kiếm nhị phân trên các truy vấn tiền tố max với Segment Tree.
Tuy nhiên, điều này sẽ dẫn đến một giải pháp <span class="arithmatex">$O(\log^2 n)$</span>.</p>
<p>Thay vào đó, chúng ta có thể sử dụng cùng một ý tưởng như trong các phần trước, và tìm vị trí bằng cách đi xuống cây:
bằng cách di chuyển mỗi lần sang trái hoặc phải, tùy thuộc vào giá trị lớn nhất của con trái.
Do đó tìm thấy câu trả lời trong thời gian <span class="arithmatex">$O(\log n)$</span>.
<div class="highlight"><span class="filename">segment_tree_first_greater</span><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">get_first</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">tl</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">tr</span><span class="o">-</span><span class="n">tl</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_first</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">get_first</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<h4 id="finding-subsegments-with-the-maximal-sum">Tìm các đoạn con có tổng lớn nhất (Finding subsegments with the maximal sum)<a class="headerlink" href="#finding-subsegments-with-the-maximal-sum" title="Permanent link">&para;</a></h4>
<p>Ở đây một lần nữa chúng ta nhận được một đoạn <span class="arithmatex">$a[l \dots r]$</span> cho mỗi truy vấn, lần này chúng ta phải tìm một đoạn con <span class="arithmatex">$a[l^\prime \dots r^\prime]$</span> sao cho <span class="arithmatex">$l \le l^\prime$</span> và <span class="arithmatex">$r^\prime \le r$</span> và tổng của các phần tử của đoạn này là lớn nhất.
Như trước đây chúng ta cũng muốn có thể sửa đổi các phần tử riêng lẻ của mảng.
Các phần tử của mảng có thể là số âm, và đoạn con tối ưu có thể rỗng (ví dụ: nếu tất cả các phần tử đều âm).</p>
<p>Bài toán này là một cách sử dụng không đơn giản của Segment Tree.
Lần này chúng ta sẽ lưu trữ bốn giá trị cho mỗi nút:
tổng của đoạn, tổng tiền tố lớn nhất, tổng hậu tố lớn nhất, và tổng của đoạn con lớn nhất trong nó.
Nói cách khác, đối với mỗi đoạn của Segment Tree, câu trả lời đã được tính toán trước cũng như các câu trả lời cho các đoạn chạm vào ranh giới bên trái và bên phải của đoạn.</p>
<p>Làm thế nào để xây dựng một cái cây với dữ liệu như vậy?
Một lần nữa chúng ta tính toán nó theo kiểu đệ quy:
đầu tiên chúng ta tính toán tất cả bốn giá trị cho con trái và con phải, và sau đó kết hợp chúng để lưu trữ bốn giá trị cho nút hiện tại.
Lưu ý câu trả lời cho nút hiện tại là một trong số:</p>
<ul>
<li>câu trả lời của con trái, có nghĩa là đoạn con tối ưu nằm hoàn toàn trong đoạn của con trái</li>
<li>câu trả lời của con phải, có nghĩa là đoạn con tối ưu nằm hoàn toàn trong đoạn của con phải</li>
<li>tổng của tổng hậu tố lớn nhất của con trái và tổng tiền tố lớn nhất của con phải, có nghĩa là đoạn con tối ưu giao với cả hai con.</li>
</ul>
<p>Do đó câu trả lời cho nút hiện tại là giá trị lớn nhất của ba giá trị này.
Việc tính toán tổng tiền tố / hậu tố lớn nhất thậm chí còn dễ dàng hơn.
Dưới đây là cài đặt của hàm <span class="arithmatex">$\text{combine}$</span>, chỉ nhận dữ liệu từ con trái và con phải, và trả về dữ liệu của nút hiện tại.
<div class="highlight"><span class="filename">segment_tree_maximal_sum_subsegments1</span><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="p">,</span><span class="w"> </span><span class="n">pref</span><span class="p">,</span><span class="w"> </span><span class="n">suff</span><span class="p">,</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">data</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">sum</span><span class="p">;</span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">pref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">pref</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">pref</span><span class="p">);</span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">suff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">suff</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">suff</span><span class="p">);</span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">ans</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">ans</span><span class="p">),</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">suff</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">pref</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Sử dụng hàm <span class="arithmatex">$\text{combine}$</span>, thật dễ dàng để xây dựng Segment Tree.
Chúng ta có thể cài đặt nó theo cách chính xác giống như trong các cài đặt trước.
Để khởi tạo các nút lá, chúng ta tạo thêm hàm phụ trợ <span class="arithmatex">$\text{make_data}$</span>, sẽ trả về một đối tượng <span class="arithmatex">$\text{data}$</span> chứa thông tin của một giá trị duy nhất.
<div class="highlight"><span class="filename">segment_tree_maximal_sum_subsegments2</span><pre><span></span><code><span class="n">data</span><span class="w"> </span><span class="nf">make_data</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">pref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">suff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_data</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">);</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_data</span><span class="p">(</span><span class="n">new_val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Chỉ còn lại, làm thế nào để tính toán câu trả lời cho một truy vấn.
Để trả lời nó, chúng ta đi xuống cây như trước, chia truy vấn thành nhiều đoạn con trùng với các đoạn của Segment Tree, và kết hợp các câu trả lời trong chúng thành một câu trả lời duy nhất cho truy vấn.
Khi đó, rõ ràng là công việc hoàn toàn giống như trong Segment Tree đơn giản, nhưng thay vì tính tổng / tối thiểu / tối đa các giá trị, chúng ta sử dụng hàm <span class="arithmatex">$\text{combine}$</span>.
<div class="highlight"><span class="filename">segment_tree_maximal_sum_subsegments3</span><pre><span></span><code><span class="n">data</span><span class="w"> </span><span class="nf">query</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">make_data</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">)),</span><span class="w"> </span>
<span class="w">                   </span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="luu-tru-toan-bo-mang-con-trong-moi-nut-saving-the-entire-subarrays-in-each-vertex"><a name="saving-the-entire-subarrays-in-each-vertex"></a>Lưu trữ toàn bộ mảng con trong mỗi nút (Saving the entire subarrays in each vertex)<a class="headerlink" href="#luu-tru-toan-bo-mang-con-trong-moi-nut-saving-the-entire-subarrays-in-each-vertex" title="Permanent link">&para;</a></h3>
<p>Đây là một tiểu mục riêng biệt đứng tách biệt với những cái khác, bởi vì tại mỗi nút của Segment Tree, chúng ta không lưu trữ thông tin về đoạn tương ứng ở dạng nén (tổng, tối thiểu, tối đa, ...), mà lưu trữ tất cả các phần tử của đoạn.
Do đó, gốc của Segment Tree sẽ lưu trữ tất cả các phần tử của mảng, nút con bên trái sẽ lưu trữ nửa đầu của mảng, nút bên phải nửa sau, v.v.</p>
<p>Trong ứng dụng đơn giản nhất của kỹ thuật này, chúng ta lưu trữ các phần tử theo thứ tự đã sắp xếp.
Trong các phiên bản phức tạp hơn, các phần tử không được lưu trữ trong danh sách, mà là các cấu trúc dữ liệu nâng cao hơn (sets, maps, ...).
Nhưng tất cả các phương pháp này đều có yếu tố chung, đó là mỗi nút yêu cầu bộ nhớ tuyến tính (tức là tỷ lệ thuận với độ dài của đoạn tương ứng).</p>
<p>Câu hỏi tự nhiên đầu tiên, khi xem xét các Segment Trees này, là về mức tiêu thụ bộ nhớ.
Theo trực giác, điều này có thể trông giống như bộ nhớ <span class="arithmatex">$O(n^2)$</span>, nhưng hóa ra toàn bộ cây sẽ chỉ cần bộ nhớ <span class="arithmatex">$O(n \log n)$</span>.
Tại sao lại như vậy?
Khá đơn giản, bởi vì mỗi phần tử của mảng rơi vào <span class="arithmatex">$O(\log n)$</span> đoạn (hãy nhớ chiều cao của cây là <span class="arithmatex">$O(\log n)$</span>).</p>
<p>Vì vậy, mặc dù có vẻ phung phí của một Segment Tree như vậy, nó chỉ tiêu thụ nhiều bộ nhớ hơn một chút so với Segment Tree thông thường.</p>
<p>Một số ứng dụng điển hình của cấu trúc dữ liệu này được mô tả dưới đây.
Điều đáng chú ý là sự tương đồng của các Segment Trees này với cấu trúc dữ liệu 2D (trên thực tế đây là cấu trúc dữ liệu 2D, nhưng với khả năng hạn chế).</p>
<h4 id="tim-so-nho-nhat-lon-hon-hoac-bang-mot-so-a-chi-inh-khong-co-truy-van-sua-oi">Tìm số nhỏ nhất lớn hơn hoặc bằng một số đã chỉ định. Không có truy vấn sửa đổi.<a class="headerlink" href="#tim-so-nho-nhat-lon-hon-hoac-bang-mot-so-a-chi-inh-khong-co-truy-van-sua-oi" title="Permanent link">&para;</a></h4>
<p>Chúng ta muốn trả lời các truy vấn có dạng sau:
đối với ba số đã cho <span class="arithmatex">$(l, r, x)$</span>, chúng ta phải tìm số nhỏ nhất trong đoạn <span class="arithmatex">$a[l \dots r]$</span> lớn hơn hoặc bằng <span class="arithmatex">$x$</span>.</p>
<p>Chúng ta xây dựng một Segment Tree.
Trong mỗi nút, chúng ta lưu trữ một danh sách đã sắp xếp của tất cả các số xuất hiện trong đoạn tương ứng, như được mô tả ở trên.
Làm thế nào để xây dựng một Segment Tree như vậy hiệu quả nhất có thể?
Như mọi khi, chúng ta tiếp cận vấn đề này một cách đệ quy: giả sử danh sách của các con bên trái và bên phải đã được xây dựng, và chúng ta muốn xây dựng danh sách cho nút hiện tại.
Từ góc nhìn này, thao tác bây giờ là tầm thường và có thể được thực hiện trong thời gian tuyến tính:
Chúng ta chỉ cần kết hợp hai danh sách đã sắp xếp thành một, có thể được thực hiện bằng cách lặp qua chúng bằng hai con trỏ.
C++ STL đã có một triển khai của thuật toán này.</p>
<p>Bởi vì cấu trúc này của Segment Tree và những điểm tương đồng với thuật toán sắp xếp trộn (merge sort), cấu trúc dữ liệu này cũng thường được gọi là "Merge Sort Tree".
<div class="highlight"><span class="filename">segment_tree_smallest_number_greater1</span><pre><span></span><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">MAXN</span><span class="p">];</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">);</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">);</span>
<span class="w">        </span><span class="n">merge</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">].</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">end</span><span class="p">(),</span>
<span class="w">              </span><span class="n">back_inserter</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Chúng ta đã biết rằng Segment Tree được xây dựng theo cách này sẽ yêu cầu bộ nhớ <span class="arithmatex">$O(n \log n)$</span>.
Và nhờ triển khai này, việc xây dựng của nó cũng mất thời gian <span class="arithmatex">$O(n \log n)$</span>, suy cho cùng, mỗi danh sách được xây dựng trong thời gian tuyến tính đối với kích thước của nó.</p>
<p>Bây giờ hãy xem xét câu trả lời cho truy vấn.
Chúng ta sẽ đi xuống cây, giống như trong Segment Tree thông thường, chia đoạn <span class="arithmatex">$a[l \dots r]$</span> của chúng ta thành nhiều đoạn con (thành tối đa <span class="arithmatex">$O(\log n)$</span> phần).
Rõ ràng là câu trả lời của toàn bộ câu trả lời là giá trị nhỏ nhất của mỗi truy vấn con.
Vì vậy, bây giờ chúng ta chỉ cần hiểu, làm thế nào để phản hồi một truy vấn trên một đoạn con như vậy tương ứng với một số nút của cây.</p>
<p>Chúng ta đang ở một nút nào đó của Segment Tree và chúng ta muốn tính toán câu trả lời cho truy vấn, tức là tìm số nhỏ nhất lớn hơn hoặc bằng một số <span class="arithmatex">$x$</span> đã cho.
Vì nút chứa danh sách các phần tử theo thứ tự đã sắp xếp, chúng ta có thể chỉ cần thực hiện tìm kiếm nhị phân trên danh sách này và trả về số đầu tiên, lớn hơn hoặc bằng <span class="arithmatex">$x$</span>.</p>
<p>Do đó, câu trả lời cho truy vấn trong một đoạn của cây mất thời gian <span class="arithmatex">$O(\log n)$</span>, và toàn bộ truy vấn được xử lý trong <span class="arithmatex">$O(\log^2 n)$</span>.
<div class="highlight"><span class="filename">segment_tree_smallest_number_greater2</span><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">query</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">INF</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lower_bound</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">end</span><span class="p">())</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">pos</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">INF</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">),</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"> </span>
<span class="w">               </span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Hằng số <span class="arithmatex">$\text{INF}$</span> bằng một số lớn nào đó lớn hơn tất cả các số trong mảng.
Việc sử dụng nó có nghĩa là, không có số nào lớn hơn hoặc bằng <span class="arithmatex">$x$</span> trong đoạn.
Nó có ý nghĩa là "không có câu trả lời trong khoảng đã cho".</p>
<h4 id="tim-so-nho-nhat-lon-hon-hoac-bang-mot-so-a-chi-inh-voi-cac-truy-van-sua-oi">Tìm số nhỏ nhất lớn hơn hoặc bằng một số đã chỉ định. Với các truy vấn sửa đổi.<a class="headerlink" href="#tim-so-nho-nhat-lon-hon-hoac-bang-mot-so-a-chi-inh-voi-cac-truy-van-sua-oi" title="Permanent link">&para;</a></h4>
<p>Nhiệm vụ này tương tự như trước.
Cách tiếp cận cuối cùng có một nhược điểm, đó là không thể sửa đổi mảng giữa các lần trả lời truy vấn.
Bây giờ chúng ta muốn làm chính xác điều này: một truy vấn sửa đổi sẽ thực hiện phép gán <span class="arithmatex">$a[i] = y$</span>.</p>
<p>Giải pháp tương tự như giải pháp của vấn đề trước, nhưng thay vì danh sách tại mỗi nút của Segment Tree, chúng ta sẽ lưu trữ một danh sách cân bằng cho phép bạn tìm kiếm nhanh các số, xóa số và chèn số mới.
Vì mảng có thể chứa một số lặp lại, lựa chọn tối ưu là cấu trúc dữ liệu <span class="arithmatex">$\text{multiset}$</span>.</p>
<p>Việc xây dựng một Segment Tree như vậy được thực hiện theo cách khá giống như trong vấn đề trước, chỉ có điều bây giờ chúng ta cần kết hợp các <span class="arithmatex">$\text{multiset}$</span> chứ không phải danh sách đã sắp xếp.
Điều này dẫn đến thời gian xây dựng là <span class="arithmatex">$O(n \log^2 n)$</span> (nói chung việc hợp nhất hai cây đỏ-đen có thể được thực hiện trong thời gian tuyến tính, nhưng C++ STL không đảm bảo độ phức tạp thời gian này).</p>
<p>Hàm <span class="arithmatex">$\text{query}$</span> cũng gần như tương đương, chỉ khác là hàm <span class="arithmatex">$\text{lower_bound}$</span> của hàm <span class="arithmatex">$\text{multiset}$</span> nên được gọi thay thế (<span class="arithmatex">$\text{std::lower_bound}$</span> chỉ hoạt động trong thời gian <span class="arithmatex">$O(\log n)$</span> nếu được sử dụng với các trình lặp truy cập ngẫu nhiên).</p>
<p>Cuối cùng là yêu cầu sửa đổi.
Để xử lý nó, chúng ta phải đi xuống cây, và sửa đổi tất cả <span class="arithmatex">$\text{multiset}$</span> từ các đoạn tương ứng có chứa phần tử bị ảnh hưởng.
Chúng ta chỉ cần xóa giá trị cũ của phần tử này (nhưng chỉ một lần xuất hiện), và chèn giá trị mới.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">erase</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">pos</span><span class="p">]));</span>
<span class="w">    </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">new_val</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">a</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_val</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Việc xử lý truy vấn sửa đổi này cũng mất thời gian <span class="arithmatex">$O(\log^2 n)$</span>.</p>
<h4 id="tim-so-nho-nhat-lon-hon-hoac-bang-mot-so-a-chi-inh-tang-toc-voi-fractional-cascading">Tìm số nhỏ nhất lớn hơn hoặc bằng một số đã chỉ định. Tăng tốc với "fractional cascading".<a class="headerlink" href="#tim-so-nho-nhat-lon-hon-hoac-bang-mot-so-a-chi-inh-tang-toc-voi-fractional-cascading" title="Permanent link">&para;</a></h4>
<p>Chúng ta có cùng một phát biểu bài toán, chúng ta muốn tìm số nhỏ nhất lớn hơn hoặc bằng <span class="arithmatex">$x$</span> trong một đoạn, nhưng lần này trong thời gian <span class="arithmatex">$O(\log n)$</span>.
Chúng ta sẽ cải thiện độ phức tạp thời gian bằng cách sử dụng kỹ thuật "fractional cascading".</p>
<p>Fractional cascading là một kỹ thuật đơn giản cho phép bạn cải thiện thời gian chạy của nhiều tìm kiếm nhị phân, được thực hiện cùng một lúc.
Cách tiếp cận trước đây của chúng ta đối với truy vấn tìm kiếm là, chúng ta chia nhiệm vụ thành nhiều nhiệm vụ con, mỗi nhiệm vụ được giải quyết bằng một tìm kiếm nhị phân.
Fractional cascading cho phép bạn thay thế tất cả các tìm kiếm nhị phân này bằng một tìm kiếm duy nhất.</p>
<p>Ví dụ đơn giản nhất và rõ ràng nhất về fractional cascading là bài toán sau:
có <span class="arithmatex">$k$</span> danh sách số đã sắp xếp, và chúng ta phải tìm trong mỗi danh sách số đầu tiên lớn hơn hoặc bằng số đã cho.</p>
<p>Thay vì thực hiện tìm kiếm nhị phân cho mỗi danh sách, chúng ta có thể hợp nhất tất cả các danh sách thành một danh sách lớn đã sắp xếp.
Ngoài ra, đối với mỗi phần tử <span class="arithmatex">$y$</span>, chúng ta lưu trữ một danh sách kết quả tìm kiếm <span class="arithmatex">$y$</span> trong mỗi danh sách trong số <span class="arithmatex">$k$</span> danh sách.
Do đó nếu chúng ta muốn tìm số nhỏ nhất lớn hơn hoặc bằng <span class="arithmatex">$x$</span>, chúng ta chỉ cần thực hiện một tìm kiếm nhị phân duy nhất, và từ danh sách các chỉ số, chúng ta có thể xác định số nhỏ nhất trong mỗi danh sách.
Tuy nhiên, cách tiếp cận này yêu cầu <span class="arithmatex">$O(n \cdot k)$</span> (<span class="arithmatex">$n$</span> là độ dài của các danh sách kết hợp), có thể khá kém hiệu quả.</p>
<p>Fractional cascading làm giảm độ phức tạp bộ nhớ này xuống <span class="arithmatex">$O(n)$</span> bộ nhớ, bằng cách tạo từ <span class="arithmatex">$k$</span> danh sách đầu vào <span class="arithmatex">$k$</span> danh sách mới, trong đó mỗi danh sách chứa danh sách tương ứng và thêm vào đó là mỗi phần tử thứ hai của danh sách mới tiếp theo.
Sử dụng cấu trúc này, chỉ cần lưu trữ hai chỉ số, chỉ số của phần tử trong danh sách gốc, và chỉ số của phần tử trong danh sách mới tiếp theo.
Vì vậy, cách tiếp cận này chỉ sử dụng <span class="arithmatex">$O(n)$</span> bộ nhớ, và vẫn có thể trả lời các truy vấn bằng cách sử dụng một tìm kiếm nhị phân duy nhất.</p>
<p>Nhưng đối với ứng dụng của chúng ta, chúng ta không cần toàn bộ sức mạnh của fractional cascading.
Trong Segment Tree của chúng ta, một nút sẽ chứa danh sách đã sắp xếp của tất cả các phần tử xuất hiện trong các cây con bên trái hoặc bên phải (giống như trong Merge Sort Tree).
Ngoài danh sách đã sắp xếp này, chúng ta lưu trữ hai vị trí cho mỗi phần tử.
Đối với một phần tử <span class="arithmatex">$y$</span>, chúng ta lưu trữ chỉ số nhỏ nhất <span class="arithmatex">$i$</span>, sao cho phần tử thứ <span class="arithmatex">$i$</span> trong danh sách đã sắp xếp của con trái lớn hơn hoặc bằng <span class="arithmatex">$y$</span>.
Và chúng ta lưu trữ chỉ số nhỏ nhất <span class="arithmatex">$j$</span>, sao cho phần tử thứ <span class="arithmatex">$j$</span> trong danh sách đã sắp xếp của con phải lớn hơn hoặc bằng <span class="arithmatex">$y$</span>.
Các giá trị này có thể được tính toán song song với bước hợp nhất khi chúng ta xây dựng cây.</p>
<p>Điều này tăng tốc các truy vấn như thế nào?</p>
<p>Hãy nhớ rằng, trong giải pháp thông thường, chúng ta đã thực hiện tìm kiếm nhị phân trong mọi nút.
Nhưng với sửa đổi này, chúng ta có thể tránh tất cả ngoại trừ một cái.</p>
<p>Để trả lời một truy vấn, chúng ta chỉ cần thực hiện tìm kiếm nhị phân trong nút gốc.
Điều này cho chúng ta phần tử nhỏ nhất <span class="arithmatex">$y \ge x$</span> trong mảng hoàn chỉnh, nhưng nó cũng cho chúng ta hai vị trí.
Chỉ số của phần tử nhỏ nhất lớn hơn hoặc bằng <span class="arithmatex">$x$</span> trong cây con trái, và chỉ số của phần tử nhỏ nhất <span class="arithmatex">$y$</span> trong cây con phải. Lưu ý rằng <span class="arithmatex">$\ge y$</span> giống như <span class="arithmatex">$\ge x$</span>, vì mảng của chúng ta không chứa bất kỳ phần tử nào giữa <span class="arithmatex">$x$</span> và <span class="arithmatex">$y$</span>.
Trong giải pháp Merge Sort Tree thông thường, chúng ta sẽ tính toán các chỉ số này thông qua tìm kiếm nhị phân, nhưng với sự trợ giúp của các giá trị đã tính toán trước, chúng ta chỉ có thể tra cứu chúng trong <span class="arithmatex">$O(1)$</span>.
Và chúng ta có thể lặp lại điều đó cho đến khi chúng ta truy cập tất cả các nút bao gồm khoảng truy vấn của chúng ta.</p>
<p>Tóm lại, như thường lệ, chúng ta chạm vào <span class="arithmatex">$O(\log n)$</span> nút trong một truy vấn. Trong nút gốc, chúng ta thực hiện tìm kiếm nhị phân, và trong tất cả các nút khác, chúng ta chỉ thực hiện công việc hằng số.
Điều này có nghĩa là độ phức tạp để trả lời một truy vấn là <span class="arithmatex">$O(\log n)$</span>.</p>
<p>Nhưng hãy chú ý rằng, điều này sử dụng bộ nhớ gấp ba lần so với Merge Sort Tree thông thường, vốn đã sử dụng rất nhiều bộ nhớ (<span class="arithmatex">$O(n \log n)$</span>).</p>
<p>Rất đơn giản để áp dụng kỹ thuật này cho một vấn đề, không yêu cầu bất kỳ truy vấn sửa đổi nào.
Hai vị trí chỉ là các số nguyên và có thể dễ dàng được tính toán bằng cách đếm khi hợp nhất hai chuỗi đã sắp xếp.</p>
<p>Vẫn có thể cho phép các truy vấn sửa đổi, nhưng điều đó làm phức tạp toàn bộ mã.
Thay vì số nguyên, bạn cần lưu trữ mảng đã sắp xếp dưới dạng <code>multiset</code>, và thay vì chỉ số, bạn cần lưu trữ trình lặp (iterators).
Và bạn cần làm việc rất cẩn thận, để bạn tăng hoặc giảm đúng các trình lặp trong một truy vấn sửa đổi.</p>
<h4 id="other-possible-variations">Các biến thể có thể khác (Other possible variations)<a class="headerlink" href="#other-possible-variations" title="Permanent link">&para;</a></h4>
<p>kỹ thuật này ngụ ý một lớp hoàn toàn mới các ứng dụng có thể.
Thay vì lưu trữ một <span class="arithmatex">$\text{vector}$</span> hoặc một <span class="arithmatex">$\text{multiset}$</span> trong mỗi nút, các cấu trúc dữ liệu khác có thể được sử dụng:
các Segment Trees khác (phần nào được thảo luận trong <a href="#generalization-to-higher-dimensions">Khái quát hóa sang các chiều cao hơn</a>), Fenwick Trees, Cartesian trees, v.v.</p>
<h3 id="range-updates-lazy-propagation">Cập nhật đoạn (Lazy Propagation)<a class="headerlink" href="#range-updates-lazy-propagation" title="Permanent link">&para;</a></h3>
<p>Tất cả các bài toán trong các phần trên đã thảo luận về các truy vấn sửa đổi chỉ ảnh hưởng đến một phần tử duy nhất của mảng mỗi lần.
Tuy nhiên, Segment Tree cho phép áp dụng các truy vấn sửa đổi cho toàn bộ một đoạn các phần tử liền kề, và thực hiện truy vấn trong cùng thời gian <span class="arithmatex">$O(\log n)$</span>.</p>
<h4 id="addition-on-segments">Cộng trên các đoạn (Addition on segments)<a class="headerlink" href="#addition-on-segments" title="Permanent link">&para;</a></h4>
<p>Chúng ta bắt đầu bằng cách xem xét các bài toán có dạng đơn giản nhất: truy vấn sửa đổi nên cộng một số <span class="arithmatex">$x$</span> vào tất cả các số trong đoạn <span class="arithmatex">$a[l \dots r]$</span>.
Truy vấn thứ hai, mà chúng ta phải trả lời, chỉ đơn giản là yêu cầu giá trị của <span class="arithmatex">$a[i]$</span>.</p>
<p>Để làm cho truy vấn cộng hiệu quả, chúng ta lưu trữ tại mỗi nút trong Segment Tree số lượng chúng ta nên cộng vào tất cả các số trong đoạn tương ứng.
Ví dụ, nếu truy vấn "cộng 3 vào toàn bộ mảng <span class="arithmatex">$a[0 \dots n-1]$</span>" đến, thì chúng ta đặt số 3 vào gốc của cây.
Nói chung, chúng ta phải đặt số này vào nhiều đoạn, tạo thành một phân vùng của đoạn truy vấn.
Do đó, chúng ta không phải thay đổi tất cả <span class="arithmatex">$O(n)$</span> giá trị, mà chỉ <span class="arithmatex">$O(\log n)$</span>.</p>
<p>Thế nên bây giờ nếu có một truy vấn hỏi giá trị hiện tại của một mục mảng cụ thể, chỉ cần đi xuống cây và cộng tất cả các giá trị tìm thấy trên đường đi.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">);</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">add</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">add</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">),</span><span class="w"> </span><span class="n">add</span><span class="p">);</span>
<span class="w">        </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="assignment-on-segments">Gán trên các đoạn (Assignment on segments)<a class="headerlink" href="#assignment-on-segments" title="Permanent link">&para;</a></h4>
<p>Bây giờ giả sử rằng truy vấn sửa đổi yêu cầu gán mỗi phần tử của một đoạn nhất định <span class="arithmatex">$a[l \dots r]$</span> cho một giá trị <span class="arithmatex">$p$</span> nào đó.
Là một truy vấn thứ hai, chúng ta sẽ xem xét lại việc đọc giá trị của mảng <span class="arithmatex">$a[i]$</span>.</p>
<p>Để thực hiện truy vấn sửa đổi này trên toàn bộ đoạn, bạn phải lưu trữ tại mỗi nút của Segment Tree xem đoạn tương ứng có được bao phủ hoàn toàn bởi cùng một giá trị hay không.
Điều này cho phép chúng ta thực hiện cập nhật "lười biếng" (lazy):
thay vì thay đổi tất cả các đoạn trong cây bao phủ đoạn truy vấn, chúng ta chỉ thay đổi một số, và để những cái khác không thay đổi.
Một nút được đánh dấu sẽ có nghĩa là, mọi phần tử của đoạn tương ứng được gán cho giá trị đó, và thực tế là toàn bộ cây con cũng chỉ nên chứa giá trị này.
Theo một nghĩa nào đó, chúng ta lười biếng và trì hoãn việc viết giá trị mới cho tất cả các nút đó.
Chúng ta có thể làm công việc tẻ nhạt này sau, nếu điều này là cần thiết.</p>
<p>Vì vậy, sau khi truy vấn sửa đổi được thực thi, một số phần của cây trở nên không liên quan - một số sửa đổi vẫn chưa được thực hiện trong đó.</p>
<p>Ví dụ nếu một truy vấn sửa đổi "gán một số cho toàn bộ mảng <span class="arithmatex">$a[0 \dots n-1]$</span>" được thực thi, trong Segment Tree chỉ có một thay đổi duy nhất được thực hiện - số được đặt vào gốc của cây và nút này được đánh dấu.
Các đoạn còn lại không thay đổi, mặc dù trên thực tế số này nên được đặt trong toàn bộ cây.</p>
<p>Bây giờ giả sử rằng truy vấn sửa đổi thứ hai nói rằng, nửa đầu của mảng <span class="arithmatex">$a[0 \dots n/2]$</span> nên được gán bằng một số khác.
Để xử lý truy vấn này, chúng ta phải gán mỗi phần tử trong toàn bộ con trái của nút gốc bằng số đó.
Nhưng trước khi chúng ta làm điều này, trước tiên chúng ta phải giải quyết nút gốc.
Sự tinh tế ở đây là nửa bên phải của mảng vẫn nên được gán cho giá trị của truy vấn đầu tiên, và tại thời điểm hiện tại không có thông tin nào cho nửa bên phải được lưu trữ.</p>
<p>Cách để giải quyết vấn đề này là đẩy (push) thông tin của gốc xuống các con của nó, tức là nếu gốc của cây được gán bằng bất kỳ số nào, thì chúng ta gán các nút con trái và phải bằng số này và loại bỏ đánh dấu của gốc.
Sau đó, chúng ta có thể gán con trái với giá trị mới mà không làm mất bất kỳ thông tin cần thiết nào.</p>
<p>Tóm lại chúng ta nhận được:
đối với bất kỳ truy vấn nào (một sửa đổi hoặc truy vấn đọc) trong quá trình đi xuống dọc theo cây, chúng ta phải luôn đẩy thông tin từ nút hiện tại vào cả hai con của nó.
Chúng ta có thể hiểu điều này theo cách như vậy, rằng khi chúng ta đi xuống cây, chúng ta áp dụng các sửa đổi bị trì hoãn, nhưng chính xác nhiều nhất mức cần thiết (để không làm giảm độ phức tạp của <span class="arithmatex">$O(\log n)$</span>).</p>
<p>Đối với việc cài đặt, chúng ta cần tạo một hàm <span class="arithmatex">$\text{push}$</span>, sẽ nhận nút hiện tại, và nó sẽ đẩy thông tin cho nút của nó đến cả hai con của nó.
Chúng ta sẽ gọi hàm này ở đầu các hàm truy vấn (nhưng chúng ta sẽ không gọi nó từ các lá, vì không cần đẩy thông tin từ chúng đi xa hơn).</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">        </span><span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_val</span><span class="p">;</span>
<span class="w">        </span><span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">),</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Lưu ý: hàm <span class="arithmatex">$\text{get}$</span> cũng có thể được cài đặt theo một cách khác:
không thực hiện các cập nhật bị trì hoãn, mà trả về ngay giá trị <span class="arithmatex">$t[v]$</span> nếu <span class="arithmatex">$marked[v]$</span> là đúng.</p>
<h4 id="adding-on-segments-querying-for-maximum">Cộng trên các đoạn, truy vấn giá trị lớn nhất (Adding on segments, querying for maximum)<a class="headerlink" href="#adding-on-segments-querying-for-maximum" title="Permanent link">&para;</a></h4>
<p>Bây giờ truy vấn sửa đổi là cộng một số vào tất cả các phần tử trong một đoạn, và truy vấn đọc là tìm giá trị lớn nhất trong một đoạn.</p>
<p>Vì vậy, đối với mỗi nút của Segment Tree, chúng ta phải lưu trữ giá trị lớn nhất của đoạn con tương ứng.
Phần thú vị là làm thế nào để tính toán lại các giá trị này trong một yêu cầu sửa đổi.</p>
<p>Vì mục đích này, chúng ta lưu trữ thêm một giá trị bổ sung cho mỗi nút.
Trong giá trị này, chúng ta lưu trữ các số hạng mà chúng ta chưa lan truyền đến các nút con.
Trước khi di chuyển đến một nút con, chúng ta gọi <span class="arithmatex">$\text{push}$</span> và lan truyền giá trị cho cả hai con.
Chúng ta phải làm điều này trong cả hàm <span class="arithmatex">$\text{update}$</span> và hàm <span class="arithmatex">$\text{query}$</span>.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">);</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">addend</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">addend</span><span class="p">;</span>
<span class="w">        </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">addend</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">),</span><span class="w"> </span><span class="n">addend</span><span class="p">);</span>
<span class="w">        </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">addend</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">query</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">INF</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">)),</span><span class="w"> </span>
<span class="w">               </span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="khai-quat-hoa-sang-cac-chieu-cao-hon-generalization-to-higher-dimensions"><a name="generalization-to-higher-dimensions"></a>Khái quát hóa sang các chiều cao hơn (Generalization to higher dimensions)<a class="headerlink" href="#khai-quat-hoa-sang-cac-chieu-cao-hon-generalization-to-higher-dimensions" title="Permanent link">&para;</a></h3>
<p>Một Segment Tree có thể được khái quát hóa khá tự nhiên sang các chiều cao hơn.
Nếu trong trường hợp một chiều, chúng ta chia các chỉ số của mảng thành các đoạn, thì trong trường hợp hai chiều, chúng ta thực hiện một Segment Tree bình thường đối với các chỉ số đầu tiên, và đối với mỗi đoạn, chúng ta xây dựng một Segment Tree bình thường đối với các chỉ số thứ hai.</p>
<h4 id="simple-2d-segment-tree">Segment Tree 2D đơn giản (Simple 2D Segment Tree)<a class="headerlink" href="#simple-2d-segment-tree" title="Permanent link">&para;</a></h4>
<p>Một ma trận <span class="arithmatex">$a[0 \dots n-1, 0 \dots m-1]$</span> được cho, và chúng ta phải tìm tổng (hoặc tối thiểu/tối đa) trên một ma trận con <span class="arithmatex">$a[x_1 \dots x_2, y_1 \dots y_2]$</span>, cũng như thực hiện sửa đổi các phần tử ma trận riêng lẻ (tức là các truy vấn có dạng <span class="arithmatex">$a[x][y] = p$</span>).</p>
<p>Vì vậy, chúng ta xây dựng một Segment Tree 2D: đầu tiên là Segment Tree sử dụng tọa độ đầu tiên (<span class="arithmatex">$x$</span>), sau đó là thứ hai (<span class="arithmatex">$y$</span>).</p>
<p>Để làm cho quá trình xây dựng dễ hiểu hơn, bạn có thể quên đi một lúc rằng ma trận là hai chiều, và chỉ để lại tọa độ đầu tiên.
Chúng ta sẽ xây dựng một Segment Tree một chiều thông thường chỉ sử dụng tọa độ đầu tiên.
Nhưng thay vì lưu trữ một số trong một đoạn, chúng ta lưu trữ một Segment Tree hoàn chỉnh:
tức là tại thời điểm này, chúng ta nhớ rằng chúng ta cũng có một tọa độ thứ hai; nhưng vì tại thời điểm này, tọa độ đầu tiên đã được cố định vào một khoảng nào đó <span class="arithmatex">$[l \dots r]$</span>, chúng ta thực sự làm việc với một dải như vậy <span class="arithmatex">$a[l \dots r, 0 \dots m-1]$</span> và đối với nó, chúng ta xây dựng một Segment Tree.</p>
<p>Dưới đây là cài đặt của việc xây dựng một Segment Tree 2D.
Nó thực sự đại diện cho hai khối riêng biệt:
việc xây dựng một Segment Tree dọc theo tọa độ <span class="arithmatex">$x$</span> (<span class="arithmatex">$\text{build}_x$</span>), và tọa độ <span class="arithmatex">$y$</span> (<span class="arithmatex">$\text{build}_y$</span>).
Đối với các nút lá trong <span class="arithmatex">$\text{build}_y$</span>, chúng ta phải phân tách hai trường hợp:
khi đoạn hiện tại của tọa độ đầu tiên <span class="arithmatex">$[tlx \dots trx]$</span> có độ dài 1, và khi nó có độ dài lớn hơn một. Trong trường hợp đầu tiên, chúng ta chỉ lấy giá trị tương ứng từ ma trận, và trong trường hợp thứ hai, chúng ta có thể kết hợp các giá trị của hai Segment Tree từ con bên trái và bên phải trong tọa độ <span class="arithmatex">$x$</span>.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">build_y</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ly</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span>
<span class="w">            </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">lx</span><span class="p">][</span><span class="n">ly</span><span class="p">];</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">vy</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">my</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ly</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">my</span><span class="p">);</span>
<span class="w">        </span><span class="n">build_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">my</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ry</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">build_x</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build_x</span><span class="p">(</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">mx</span><span class="p">);</span>
<span class="w">        </span><span class="n">build_x</span><span class="p">(</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">mx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">build_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="mi">-1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Một Segment Tree như vậy vẫn sử dụng một lượng bộ nhớ tuyến tính, nhưng với hằng số lớn hơn: <span class="arithmatex">$16 n m$</span>.
Rõ ràng là thủ tục được mô tả <span class="arithmatex">$\text{build}_x$</span> cũng hoạt động trong thời gian tuyến tính.</p>
<p>Bây giờ chúng ta chuyển sang xử lý các truy vấn. Chúng ta sẽ trả lời truy vấn hai chiều bằng cùng một nguyên tắc:
đầu tiên phá vỡ truy vấn trên tọa độ đầu tiên, và sau đó đối với mỗi nút đạt được, chúng ta gọi Segment Tree tương ứng của tọa độ thứ hai.</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">sum_y</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tly</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">try_</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ly</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ly</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tly</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">try_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tmy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tly</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">try_</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tly</span><span class="p">,</span><span class="w"> </span><span class="n">tmy</span><span class="p">,</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">ry</span><span class="p">,</span><span class="w"> </span><span class="n">tmy</span><span class="p">))</span>
<span class="w">         </span><span class="o">+</span><span class="w"> </span><span class="n">sum_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tmy</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">try_</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">tmy</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">ry</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">sum_x</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tlx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">trx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tlx</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">trx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">sum_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">ry</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tmx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tlx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">trx</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum_x</span><span class="p">(</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tlx</span><span class="p">,</span><span class="w"> </span><span class="n">tmx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">tmx</span><span class="p">),</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span>
<span class="w">         </span><span class="o">+</span><span class="w"> </span><span class="n">sum_x</span><span class="p">(</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tmx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">trx</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">tmx</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">ry</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Hàm này hoạt động trong thời gian <span class="arithmatex">$O(\log n \log m)$</span>, vì ban đầu nó đi xuống cây ở tọa độ đầu tiên, và đối với mỗi nút được duyệt trong cây, nó thực hiện một truy vấn trong Segment Tree tương ứng dọc theo tọa độ thứ hai.</p>
<p>Cuối cùng chúng ta xem xét truy vấn sửa đổi.
Chúng ta muốn học cách sửa đổi Segment Tree theo sự thay đổi giá trị của một phần tử nào đó <span class="arithmatex">$a[x][y] = p$</span>.
Rõ ràng là, những thay đổi sẽ chỉ xảy ra trong những nút của Segment Tree đầu tiên bao gồm tọa độ <span class="arithmatex">$x$</span> (và số lượng đó sẽ là <span class="arithmatex">$O(\log n)$</span>), và đối với các Segment Tree tương ứng với chúng, các thay đổi sẽ chỉ xảy ra tại những nút bao gồm tọa độ <span class="arithmatex">$y$</span> (và số lượng đó sẽ là <span class="arithmatex">$O(\log m)$</span>).
Do đó, việc cài đặt sẽ không khác nhiều so với trường hợp một chiều, chỉ có điều bây giờ chúng ta đi xuống tọa độ đầu tiên trước, và sau đó là tọa độ thứ hai.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">update_y</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ry</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ly</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span>
<span class="w">            </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_val</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">vy</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">my</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ly</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">my</span><span class="p">)</span>
<span class="w">            </span><span class="n">update_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">my</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">update_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">my</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ry</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">update_x</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">mx</span><span class="p">)</span>
<span class="w">            </span><span class="n">update_x</span><span class="p">(</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">mx</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">update_x</span><span class="p">(</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">mx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">update_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="compression-of-2d-segment-tree">Nén Segment Tree 2D (Compression of 2D Segment Tree)<a class="headerlink" href="#compression-of-2d-segment-tree" title="Permanent link">&para;</a></h4>
<p>Giả sử bài toán là như sau: có <span class="arithmatex">$n$</span> điểm trên mặt phẳng được cho bởi tọa độ của chúng <span class="arithmatex">$(x_i, y_i)$</span> và các truy vấn có dạng "đếm số lượng điểm nằm trong hình chữ nhật <span class="arithmatex">$((x_1, y_1), (x_2, y_2))$</span>".
Rõ ràng là trong trường hợp của một bài toán như vậy, việc xây dựng một Segment Tree hai chiều với <span class="arithmatex">$O(n^2)$</span> phần tử trở nên lãng phí một cách vô lý.
Hầu hết bộ nhớ này sẽ bị lãng phí, vì mỗi điểm đơn lẻ chỉ có thể đi vào <span class="arithmatex">$O(\log n)$</span> đoạn của cây dọc theo tọa độ đầu tiên, và do đó tổng kích thước "hữu ích" của tất cả các đoạn cây trên tọa độ thứ hai là <span class="arithmatex">$O(n \log n)$</span>.</p>
<p>Vì vậy, chúng ta tiến hành như sau:
tại mỗi nút của Segment Tree đối với tọa độ đầu tiên, chúng ta lưu trữ một Segment Tree được xây dựng chỉ bởi những tọa độ thứ hai xảy ra trong đoạn hiện tại của tọa độ đầu tiên.
Nói cách khác, khi xây dựng một Segment Tree bên trong một nút có chỉ số <span class="arithmatex">$vx$</span> và các ranh giới <span class="arithmatex">$tlx$</span> và <span class="arithmatex">$trx$</span>, chúng ta chỉ xem xét những điểm rơi vào khoảng này <span class="arithmatex">$x \in [tlx, trx]$</span>, và xây dựng một Segment Tree chỉ sử dụng chúng.</p>
<p>Do đó, chúng ta sẽ đạt được rằng mỗi Segment Tree trên tọa độ thứ hai sẽ chiếm chính xác nhiều bộ nhớ như nó nên.
Kết quả là, tổng lượng bộ nhớ sẽ giảm xuống <span class="arithmatex">$O(n \log n)$</span>.
Chúng ta vẫn có thể trả lời các truy vấn trong thời gian <span class="arithmatex">$O(\log^2 n)$</span>, chúng ta chỉ cần thực hiện tìm kiếm nhị phân trên tọa độ thứ hai, nhưng điều này sẽ không làm xấu đi độ phức tạp.</p>
<p>Nhưng các truy vấn sửa đổi sẽ là không thể với cấu trúc này:
trên thực tế nếu một điểm mới xuất hiện, chúng ta phải thêm một phần tử mới vào giữa một Segment Tree nào đó dọc theo tọa độ thứ hai, điều này không thể được thực hiện một cách hiệu quả.</p>
<p>Kết luận, chúng ta lưu ý rằng Segment Tree hai chiều được rút gọn theo cách được mô tả trở nên gần như tương đương với việc sửa đổi Segment Tree một chiều (xem <a href="#saving-the-entire-subarrays-in-each-vertex">Lưu trữ toàn bộ mảng con trong mỗi nút</a>).
Đặc biệt, Segment Tree hai chiều chỉ là một trường hợp đặc biệt của việc lưu trữ một mảng con trong mỗi nút của cây.
Theo đó, nếu bạn phải từ bỏ Segment Tree hai chiều do không thể thực hiện truy vấn, thì việc thay thế Segment Tree lồng nhau bằng một cấu trúc dữ liệu mạnh hơn, ví dụ như Cartesian tree, là điều hợp lý.</p>
<h3 id="preserving-the-history-of-its-values-persistent-segment-tree">Bảo tồn lịch sử các giá trị của nó (Persistent Segment Tree)<a class="headerlink" href="#preserving-the-history-of-its-values-persistent-segment-tree" title="Permanent link">&para;</a></h3>
<p>Một cấu trúc dữ liệu persistent là một cấu trúc dữ liệu ghi nhớ trạng thái trước đó của nó cho mỗi lần sửa đổi.
Điều này cho phép truy cập bất kỳ phiên bản nào của cấu trúc dữ liệu này mà chúng ta quan tâm và thực hiện truy vấn trên đó.</p>
<p>Segment Tree là một cấu trúc dữ liệu có thể được biến thành một cấu trúc dữ liệu persistent một cách hiệu quả (cả về thời gian và mức tiêu thụ bộ nhớ).
Chúng ta muốn tránh sao chép toàn bộ cây trước mỗi lần sửa đổi, và chúng ta không muốn mất hành vi thời gian <span class="arithmatex">$O(\log n)$</span> để trả lời các truy vấn đoạn.</p>
<p>Trên thực tế, bất kỳ yêu cầu thay đổi nào trong Segment Tree đều dẫn đến sự thay đổi dữ liệu của chỉ <span class="arithmatex">$O(\log n)$</span> nút dọc theo đường đi bắt đầu từ gốc.
Vì vậy, nếu chúng ta lưu trữ Segment Tree bằng cách sử dụng các con trỏ (tức là một nút lưu trữ các con trỏ đến các nút con trái và phải), thì khi thực hiện truy vấn sửa đổi, chúng ta chỉ cần tạo các nút mới thay vì thay đổi các nút có sẵn.
Các nút không bị ảnh hưởng bởi truy vấn sửa đổi vẫn có thể được sử dụng bằng cách trỏ các con trỏ đến các nút cũ.
Do đó, đối với một truy vấn sửa đổi, <span class="arithmatex">$O(\log n)$</span> nút mới sẽ được tạo, bao gồm một nút gốc mới của Segment Tree, và toàn bộ phiên bản trước đó của cây bắt nguồn từ nút gốc cũ sẽ không thay đổi.</p>
<p>Hãy đưa ra một ví dụ cài đặt cho Segment Tree đơn giản nhất: khi chỉ có một truy vấn yêu cầu tổng, và các truy vấn sửa đổi của các phần tử đơn lẻ.</p>
<p><div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Vertex</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="o">*</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">r</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>

<span class="w">    </span><span class="n">Vertex</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">Vertex</span><span class="p">(</span><span class="n">Vertex</span><span class="w"> </span><span class="o">*</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">Vertex</span><span class="w"> </span><span class="o">*</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="p">(</span><span class="n">l</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">(</span><span class="n">r</span><span class="p">),</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">l</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">]);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">),</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">get_sum</span><span class="p">(</span><span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">get_sum</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">))</span>
<span class="w">         </span><span class="o">+</span><span class="w"> </span><span class="n">get_sum</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">new_val</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">),</span><span class="w"> </span><span class="n">v</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
Đối với mỗi lần sửa đổi của Segment Tree, chúng ta sẽ nhận được một nút gốc mới.
Để nhanh chóng chuyển đổi giữa hai phiên bản khác nhau của Segment Tree, chúng ta cần lưu trữ các gốc này trong một mảng.
Để sử dụng một phiên bản cụ thể của Segment Tree, chúng ta chỉ cần gọi truy vấn bằng nút gốc thích hợp.</p>
<p>Với cách tiếp cận được mô tả ở trên, hầu hết mọi Segment Tree đều có thể được biến thành một cấu trúc dữ liệu persistent.</p>
<h4 id="finding-the-k-th-smallest-number-in-a-range">Tìm số nhỏ thứ <span class="arithmatex">$k$</span> trong một đoạn (Finding the <span class="arithmatex">$k$</span>-th smallest number in a range)<a class="headerlink" href="#finding-the-k-th-smallest-number-in-a-range" title="Permanent link">&para;</a></h4>
<p>Lần này chúng ta phải trả lời các truy vấn có dạng "Phần tử nhỏ thứ <span class="arithmatex">$k$</span> trong đoạn <span class="arithmatex">$a[l \dots r]$</span> là gì".
Truy vấn này có thể được trả lời bằng cách sử dụng tìm kiếm nhị phân và Merge Sort Tree, nhưng độ phức tạp thời gian cho một truy vấn đơn lẻ sẽ là <span class="arithmatex">$O(\log^3 n)$</span>.
Chúng ta sẽ hoàn thành nhiệm vụ tương tự bằng cách sử dụng Segment Tree persistent trong <span class="arithmatex">$O(\log n)$</span>.</p>
<p>Đầu tiên chúng ta sẽ thảo luận về một giải pháp cho một vấn đề đơn giản hơn:
Chúng ta sẽ chỉ xem xét các mảng trong đó các phần tử bị giới hạn bởi <span class="arithmatex">$0 \le a[i] \lt n$</span>.
Và chúng ta chỉ muốn tìm phần tử nhỏ thứ <span class="arithmatex">$k$</span> trong một tiền tố nào đó của mảng <span class="arithmatex">$a$</span>.
Sẽ rất dễ dàng để mở rộng các ý tưởng đã phát triển sau này cho các mảng không bị hạn chế và các truy vấn đoạn không bị hạn chế.
Lưu ý rằng chúng ta sẽ sử dụng chỉ mục dựa trên 1 cho <span class="arithmatex">$a$</span>.</p>
<p>Chúng ta sẽ sử dụng một Segment Tree đếm tất cả các số xuất hiện, tức là trong Segment Tree chúng ta sẽ lưu trữ biểu đồ tần suất (histogram) của mảng.
Vì vậy, các nút lá sẽ lưu trữ tần suất các giá trị <span class="arithmatex">$0$</span>, <span class="arithmatex">$1$</span>, <span class="arithmatex">$\dots$</span>, <span class="arithmatex">$n-1$</span> sẽ xuất hiện trong mảng, và các nút khác lưu trữ có bao nhiêu số trong một phạm vi nào đó nằm trong mảng.
Nói cách khác, chúng ta tạo một Segment Tree thông thường với các truy vấn tổng trên biểu đồ tần suất của mảng.
Nhưng thay vì tạo tất cả <span class="arithmatex">$n$</span> Segment Trees cho mọi tiền tố có thể, chúng ta sẽ tạo một cái persistent, sẽ chứa cùng thông tin.
Chúng ta sẽ bắt đầu với một Segment Tree rỗng (tất cả các số đếm sẽ là <span class="arithmatex">$0$</span>) được trỏ bởi <span class="arithmatex">$root_0$</span>, và thêm các phần tử <span class="arithmatex">$a[1]$</span>, <span class="arithmatex">$a[2]$</span>, <span class="arithmatex">$\dots$</span>, <span class="arithmatex">$a[n]$</span> lần lượt.
Đối với mỗi thay đổi, chúng ta sẽ nhận được một nút gốc mới, hãy gọi <span class="arithmatex">$root_i$</span> là gốc của Segment Tree sau khi chèn <span class="arithmatex">$i$</span> phần tử đầu tiên của mảng <span class="arithmatex">$a$</span>.
Segment Tree có gốc tại <span class="arithmatex">$root_i$</span> sẽ chứa biểu đồ tần suất của tiền tố <span class="arithmatex">$a[1 \dots i]$</span>.
Sử dụng Segment Tree này, chúng ta có thể tìm thấy trong thời gian <span class="arithmatex">$O(\log n)$</span> vị trí của phần tử thứ <span class="arithmatex">$k$</span> bằng cách sử dụng cùng kỹ thuật đã thảo luận trong <a href="#counting-zero-search-kth">Đếm số lượng số 0, tìm số 0 thứ <span class="arithmatex">$k$</span></a>.</p>
<p>Bây giờ đến phiên bản không hạn chế của vấn đề.</p>
<p>Đầu tiên đối với hạn chế về các truy vấn:
Thay vì chỉ thực hiện các truy vấn này trên một tiền tố của <span class="arithmatex">$a$</span>, chúng ta muốn sử dụng bất kỳ đoạn tùy ý nào <span class="arithmatex">$a[l \dots r]$</span>.
Ở đây chúng ta cần một Segment Tree đại diện cho biểu đồ tần suất của các phần tử trong đoạn <span class="arithmatex">$a[l \dots r]$</span>.
Dễ thấy rằng một Segment Tree như vậy chỉ là sự khác biệt giữa Segment Tree có gốc tại <span class="arithmatex">$root_{r}$</span> và Segment Tree có gốc tại <span class="arithmatex">$root_{l-1}$</span>, tức là mọi nút trong Segment Tree <span class="arithmatex">$[l \dots r]$</span> có thể được tính bằng nút của cây <span class="arithmatex">$root_{r}$</span> trừ đi nút của cây <span class="arithmatex">$root_{l-1}$</span>.</p>
<p>Trong việc cài đặt hàm <span class="arithmatex">$\text{find_kth}$</span>, điều này có thể được xử lý bằng cách truyền hai con trỏ nút và tính toán số đếm/tổng của đoạn hiện tại dưới dạng hiệu của hai số đếm/tổng của các nút.</p>
<p>Dưới đây là các hàm <span class="arithmatex">$\text{build}$</span>, <span class="arithmatex">$\text{update}$</span> và <span class="arithmatex">$\text{find_kth}$</span> đã sửa đổi
<div class="highlight"><span class="filename">kth_smallest_persistent_segment_tree</span><pre><span></span><code><span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">build</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">),</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">sum</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">),</span><span class="w"> </span><span class="n">v</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">find_kth</span><span class="p">(</span><span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="n">vl</span><span class="p">,</span><span class="w"> </span><span class="n">Vertex</span><span class="w"> </span><span class="o">*</span><span class="n">vr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">tl</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">left_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vr</span><span class="o">-&gt;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">sum</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vl</span><span class="o">-&gt;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">left_count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">find_kth</span><span class="p">(</span><span class="n">vl</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">vr</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">find_kth</span><span class="p">(</span><span class="n">vl</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">vr</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="o">-</span><span class="n">left_count</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Như đã viết ở trên, chúng ta cần lưu trữ gốc của Segment Tree ban đầu, và cả tất cả các gốc sau mỗi lần cập nhật.
Dưới đây là mã để xây dựng một Segment Tree persistent trên một vector <code>a</code> với các phần tử trong phạm vi <code>[0, MAX_VALUE]</code>.
<div class="highlight"><span class="filename">kth_smallest_persistent_segment_tree_build</span><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX_VALUE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">roots</span><span class="p">;</span>
<span class="n">roots</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">build</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">));</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">roots</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">update</span><span class="p">(</span><span class="n">roots</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="p">}</span>

<span class="c1">// find the 5th smallest number from the subarray [a[2], a[3], ..., a[19]]</span>
<span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_kth</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">roots</span><span class="p">[</span><span class="mi">20</span><span class="p">],</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
</code></pre></div></p>
<p>Bây giờ đến các hạn chế về các phần tử mảng:
Chúng ta thực sự có thể chuyển đổi bất kỳ mảng nào thành một mảng như vậy bằng cách nén chỉ mục.
Phần tử nhỏ nhất trong mảng sẽ được gán giá trị 0, nhỏ thứ hai là giá trị 1, v.v.
Thật dễ dàng để tạo các bảng tra cứu (ví dụ: sử dụng <span class="arithmatex">$\text{map}$</span>), chuyển đổi một giá trị thành chỉ số của nó và ngược lại trong thời gian <span class="arithmatex">$O(\log n)$</span>.</p>
<h3 id="dynamic-segment-tree">Segment tree động (Dynamic segment tree)<a class="headerlink" href="#dynamic-segment-tree" title="Permanent link">&para;</a></h3>
<p>(Được gọi như vậy vì hình dạng của nó là động và các nút thường được phân bổ động.
Còn được gọi là <em>implicit segment tree</em> (segment tree ngầm) hoặc <em>sparse segment tree</em> (segment tree thưa).)</p>
<p>Trước đây, chúng ta đã xem xét các trường hợp khi chúng ta có khả năng xây dựng segment tree ban đầu. Nhưng phải làm gì nếu kích thước ban đầu được lấp đầy bằng một số phần tử mặc định, nhưng kích thước của nó không cho phép bạn xây dựng hoàn toàn cho đến nó trước?</p>
<p>Chúng ta có thể giải quyết vấn đề này bằng cách tạo một segment tree một cách lười biếng (tăng dần). Ban đầu, chúng ta sẽ chỉ tạo gốc, và chúng ta sẽ chỉ tạo các nút khác khi chúng ta cần chúng.
Trong trường hợp này, chúng ta sẽ sử dụng cài đặt trên con trỏ (trước khi đi đến con của nút, hãy kiểm tra xem chúng đã được tạo chưa, và nếu chưa, hãy tạo chúng).
Mỗi truy vấn vẫn chỉ có độ phức tạp <span class="arithmatex">$O(\log n)$</span>, đủ nhỏ cho hầu hết các trường hợp sử dụng (ví dụ: <span class="arithmatex">$\log_2 10^9 \approx 30$</span>).</p>
<p>Trong cài đặt này, chúng ta có hai truy vấn, thêm một giá trị vào một vị trí (ban đầu tất cả các giá trị là <span class="arithmatex">$0$</span>), và tính tổng của tất cả các giá trị trong một đoạn.
<code>Vertex(0, n)</code> sẽ là nút gốc của cây ngầm.</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Vertex</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="o">*</span><span class="n">left_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">right_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="w">    </span><span class="n">Vertex</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lb</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rb</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lb</span><span class="p">;</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rb</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">extend</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">left_child</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="n">left_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span>
<span class="w">            </span><span class="n">right_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">extend</span><span class="p">();</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">left_child</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">left_child</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
<span class="w">                </span><span class="n">left_child</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">                </span><span class="n">right_child</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">get_sum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lq</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rq</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lq</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">rq</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">lq</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">rq</span><span class="p">))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">extend</span><span class="p">();</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">left_child</span><span class="o">-&gt;</span><span class="n">get_sum</span><span class="p">(</span><span class="n">lq</span><span class="p">,</span><span class="w"> </span><span class="n">rq</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right_child</span><span class="o">-&gt;</span><span class="n">get_sum</span><span class="p">(</span><span class="n">lq</span><span class="p">,</span><span class="w"> </span><span class="n">rq</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>Rõ ràng ý tưởng này có thể được mở rộng theo nhiều cách khác nhau. Ví dụ: bằng cách thêm hỗ trợ cho cập nhật đoạn thông qua lazy propagation.</p>
<h2 id="practice-problems">Bài tập (Practice Problems)<a class="headerlink" href="#practice-problems" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="http://www.spoj.com/problems/KQUERY/">SPOJ - KQUERY</a> [Persistent segment tree / Merge sort tree]</li>
<li><a href="https://codeforces.com/problemset/problem/339/D">Codeforces - Xenia and Bit Operations</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2397">UVA 11402 - Ahoy, Pirates!</a></li>
<li><a href="http://www.spoj.com/problems/GSS3/">SPOJ - GSS3</a></li>
<li><a href="https://codeforces.com/problemset/problem/1234/D">Codeforces - Distinct Characters Queries</a></li>
<li><a href="https://codeforces.com/contest/356/problem/A">Codeforces - Knight Tournament</a> [For beginners]</li>
<li><a href="https://codeforces.com/contest/474/problem/F">Codeforces - Ant colony</a></li>
<li><a href="https://codeforces.com/contest/515/problem/E">Codeforces - Drazil and Park</a></li>
<li><a href="https://codeforces.com/problemset/problem/52/C">Codeforces - Circular RMQ</a></li>
<li><a href="https://codeforces.com/contest/121/problem/E">Codeforces - Lucky Array</a></li>
<li><a href="https://codeforces.com/contest/438/problem/D">Codeforces - The Child and Sequence</a></li>
<li><a href="https://codeforces.com/contest/446/problem/C">Codeforces - DZY Loves Fibonacci Numbers</a> [Lazy propagation]</li>
<li><a href="https://codeforces.com/problemset/problem/610/E">Codeforces - Alphabet Permutations</a></li>
<li><a href="https://codeforces.com/problemset/problem/895/E">Codeforces - Eyes Closed</a></li>
<li><a href="https://codeforces.com/problemset/problem/580/E">Codeforces - Kefa and Watch</a></li>
<li><a href="https://codeforces.com/problemset/problem/558/E">Codeforces - A Simple Task</a></li>
<li><a href="https://codeforces.com/problemset/problem/920/F">Codeforces - SUM and REPLACE</a></li>
<li><a href="https://codeforces.com/problemset/problem/242/E">Codeforces - XOR on Segment</a> [Lazy propagation]</li>
<li><a href="https://codeforces.com/problemset/problem/1114/F">Codeforces - Please, another Queries on Array?</a> [Lazy propagation]</li>
<li><a href="https://oj.uz/problem/view/COCI17_deda">COCI - Deda</a> [Last element smaller or equal to x / Binary search]</li>
<li><a href="https://codeforces.com/problemset/problem/869/E">Codeforces - The Untended Antiquity</a> [2D]</li>
<li><a href="https://cses.fi/problemset/task/1143">CSES - Hotel Queries</a></li>
<li><a href="https://cses.fi/problemset/task/1736">CSES - Polynomial Queries</a></li>
<li><a href="https://cses.fi/problemset/task/1735">CSES - Range Updates and Sums</a></li>
</ul>
                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      

<footer class="md-footer">
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Text is available under the <a href="https://github.com/deanqkhanhcoder/cp-algorithms-vi/blob/main/LICENSE">Creative Commons Attribution Share Alike 4.0 International</a> License<br/>Copyright &copy; 2014 - 2025
          </div>
        
        
        
      </div>
      
<div class="md-social">
  
</div>
    </div>
  </div>
</footer>

    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "..", "features": ["navigation.top", "navigation.tracking", "toc.follow", "toc.integrate", "search.suggest", "content.code.copy"], "search": "../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.79ae519e.min.js"></script>
      
        <script src="../javascript/config.js"></script>
      
        <script src="../javascript/donation-banner.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>